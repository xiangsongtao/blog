{"componentChunkName":"component---src-templates-author-page-js","path":"/author/烈风裘/2","result":{"data":{"authorJson":{"id":"烈风裘","bio":"一往无前, 直到云开雾散!","avatar":"/avatar/avatar.jpeg","cover":"/background/photo-1503197979108-c824168d51a8.jpeg","github":"https://github.com/xiangst0816","twitter":"","zhihu":"","weibo":"","facebook":"","website":"https://xiangst0816.github.io/blog/","location":"HangZhou, China"},"allAuthorJson":{"totalCount":2,"edges":[{"node":{"id":"烈风裘","avatar":"/avatar/avatar.jpeg"}},{"node":{"id":"WALL-E","avatar":"/avatar/cleaner.jpg"}}]},"site":{"siteMetadata":{"title":"Attila","cover":"/background/1.jpg","author":"@烈风裘","description":"Thoughts, stories and ideas.","keywords":["烈风裘的博客","X-Blog","Attila","Gatsby","前端成长记录"],"tagCover":"/background/5.jpg","archiveCover":"/background/escape-flight.png","siteUrl":"https://xiangst0816.github.io/blog","logo":"","navigation":true,"subscribe":true}},"otherAuthorsInfo":{"edges":[{"node":{"id":"WALL-E","avatar":"/avatar/cleaner.jpg","master":false}}]},"allMarkdownRemark":{"totalCount":85},"currentMarkdownRemark":{"totalCount":85,"edges":[{"node":{"excerpt":"这篇文章总结 class 相关，并辐射出周边需要了解的知识点，便于形成巩固自己的心理表征。 如何编写一个类？ 在 ES6 还没出来之前，前端在编写 class 时，相比去其他设计成熟的语言会显得很诡异，比如使用 JS 原生的方式实现一个类继承，这个我在之前的文章中有说明。 第六章 面相对象的程序设计(简单实现一个最理想的继承范式?) 第六章 面相对象的程序设计(new 操作符执行的过程?) 下面是 UML 说明：  传统的基于原型的实现： ES6 出来之后，关于 class…","fields":{"slug":"/guan-yu-class/"},"frontmatter":{"title":"关于class","tags":["设计模式"],"star":false,"date":"30 Jun 2018","author":"烈风裘"}}},{"node":{"excerpt":"书中的训练方法自己还在上学期间就在大脑中有些印象，比如归纳总结找出共同点或者规律，便于以后相同问题能快速解决等。但是，我把“刻意练习”的方法使用的比较局限。我觉得在生活的方方面面都能刻意的使用“刻意练习”的方法来做，而不只是爱好或者工作。  下面是我的读书总结，希望能对你有用：","fields":{"slug":"/ke-yi-lian-xi/"},"frontmatter":{"title":"刻意练习","tags":["读书"],"star":false,"date":"23 May 2018","author":"烈风裘"}}},{"node":{"excerpt":"在读这本书的同时也是在进行高效阅读的实践，因为我性子比较急，做事强调结果，有很强的目的性。这样的性格特点和书中的一些观点结论不谋而合，下面进行总结回顾。  读书目的 带着目的或者问题看书，重点部分只占 2…","fields":{"slug":"/how-to-read/"},"frontmatter":{"title":"如何高效阅读","tags":["读书"],"star":false,"date":"02 May 2018","author":"烈风裘"}}},{"node":{"excerpt":"本书是著名博主张鑫旭的呕心沥血之作，涵盖了 CSS2.1 版本需要注意和知道的常用知识，我这里在看书总结时对以往不太清楚的地方做个深入整理，理清自己的知识体系树。 知识应该成体系才能方便我们日后工作中对内部信息进行快速检索，所以我在看这本书的同时会画一些结构树（思维导图），以便让我能更深入的理解 CSS 中的一些“怪异、特殊”的行为。 需要重点说明的是：本书是对 CSS2.1 的介绍与总结，最新的 CSS3 的内容需要从别的地方获取资料学习。 前言 了解“流” HTML+CSS…","fields":{"slug":"/css-xin-shi-jie/"},"frontmatter":{"title":"CSS新世界","tags":["总结"],"star":false,"date":"14 Apr 2018","author":"烈风裘"}}},{"node":{"excerpt":"解决题述的问题需要清楚用户在滑动页面时，Chrome 在背后的工作过程，了解了工作过程解题就会水到渠成。 基础：Chrome 线程化渲染框架 之前提到过这样的一个浏览器渲染线性流程，这里简单说下：  在传统浏览器中，主线程的执行是单线程渲染模式，JS 执行及页面布局渲染在一个线程中串行执行（根据修改的 CSS 元素不同会跳过部分执行阶段）。为了保证 UI 流畅需要每一帧上述的处理时间小于 10ms。 为了优化上述过程，Chrome 浏览器内核对Composite…","fields":{"slug":"/ru-he-chu-li-gun/"},"frontmatter":{"title":"如何处理滚动优化","tags":["总结"],"star":false,"date":"11 Apr 2018","author":"烈风裘"}}},{"node":{"excerpt":"PDF 下载地址：CSSConf.pdf 这个 Slides 是参加 CSS 大会的总结，因为要对小伙伴们分享，因此这个总结会比较“大”。是的，我搜集了四届的大会报告做了总结，引用的文章在每个 Slide 的页脚。 所谓一通百通，我希望这个 Slides 能帮到你理清 CSS 的脉络！ BigMap  根据我搜集的 21 个报告做的如下分类。根据 CSS 展开，包括：组件库中 CSS 的位置、响应式、CSS 编译器、动画及性能、CSS…","fields":{"slug":"/css-zong-jie/"},"frontmatter":{"title":"CSSConf 总结","tags":["总结"],"star":false,"date":"10 Apr 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. 什么是 SSR？什么情况下需要使用 SSR？ SSR（Server Side Render）服务端渲染，这里主要是为了解决 SPA 应用首屏加载缓慢、白屏的问题。用户在访问 SPA 应用时，服务端（Nodejs）先获取页面需要的数据生成 HTML 字符串传递给客户端用于首屏显示，随后再加载其余资源进行渲染结果比对和后渲染流程。 2. 传统 SPA 渲染过程和 SSR 渲染过程有何不同？ 下面是两种方式的时序图： 客户端渲染  服务端渲染  注意： SSR 可以在 事件前（css…","fields":{"slug":"/ssr-xiang-guan-wen-da/"},"frontmatter":{"title":"SSR相关","tags":["总结"],"star":false,"date":"29 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"缘由 记得第一次看《JavaScript 高级程序设计》这本书是在两年前刚接触前端，花了一点时间大致翻阅了下，随后就把这本书当做工具书来用。工作两年后，虽然面对的业务千奇百怪但都能查查手册 Cover…","fields":{"slug":"/js-gao-cheng-wen-da/"},"frontmatter":{"title":"JS高程问答","tags":["JS高程"],"star":false,"date":"27 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"这里所指都是在浏览器环境中，而不是 Nodejs 环境。 JS 异步机制 关于 JS 简要的运行机制及事件队列等知识强烈希望能翻墙看下这个视频：地址。 这里有个很重要的图需要深刻理解：  Chrome 中的 V8 只处理 JS 的解析及执行（可能有歧义） JS 运行在单线程上，通过 event loop 完成异步调度 DOM、XMLHTTPREquest、setTimeout、setInterval 等是异步的 WebAPIs 异步代码会被推入 callback queue（Tasks…","fields":{"slug":"/js-shi-jian-ji-zhi/"},"frontmatter":{"title":"JS事件机制及Tasks和microtasks的区别","tags":["JavaScript"],"star":false,"date":"24 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"占坑，内容会陆续补齐 1. URL->IP 将输入的域名转化为真实的 IP 地址，这里涉及到 DNS 层层向外查找等内容。 2. IP->HTTP 拿到远端的 IP 地址，浏览器向服务器发送 HTTP 请求，包括相应的请求头 3. HTTP->TCP 4. 服务端部分 4.1 负载均衡 5. 浏览器接收数据 6. 浏览器解析 HTML 流程 浏览器渲染过程，资源加载同步异步 7. 浏览器资源加载过程 keep-alive、缓存、HTTP1.0、HTTP1.1、HTTPS、HTTP2.0…","fields":{"slug":"/cong-shu-ru-url-dao/"},"frontmatter":{"title":"从输入URL到页面显示过程中发生的事儿","tags":["随笔"],"star":true,"date":"22 Mar 2018","author":"烈风裘"}}}]}},"pageContext":{"skip":10,"limit":10,"author":"烈风裘"}},"staticQueryHashes":["3240721340","63159454"]}