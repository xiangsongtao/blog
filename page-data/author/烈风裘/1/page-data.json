{"componentChunkName":"component---src-templates-author-page-js","path":"/author/烈风裘/1","result":{"data":{"authorJson":{"id":"烈风裘","bio":"一往无前, 直到云开雾散!","avatar":"/avatar/me.jpeg","cover":"/background/photo-1503197979108-c824168d51a8.jpeg","github":"https://github.com/xiangsongtao","twitter":"","zhihu":"","weibo":"","facebook":"","website":"https://xiangsongtao.github.io/blog/","location":"HangZhou, China"},"allAuthorJson":{"totalCount":2,"edges":[{"node":{"id":"烈风裘","avatar":"/avatar/me.jpeg"}},{"node":{"id":"WALL-E","avatar":"/avatar/cleaner.jpg"}}]},"site":{"siteMetadata":{"title":"Attila","cover":"/background/1.jpg","author":"@烈风裘","description":"Thoughts, stories and ideas.","keywords":["烈风裘的博客","X-Blog","Attila","Gatsby","前端成长记录"],"tagCover":"/background/5.jpg","archiveCover":"/background/escape-flight.png","siteUrl":"https://xiangst0816.github.io/blog","logo":"","navigation":true,"subscribe":true}},"otherAuthorsInfo":{"edges":[{"node":{"id":"WALL-E","avatar":"/avatar/cleaner.jpg","master":false}}]},"allMarkdownRemark":{"totalCount":85},"currentMarkdownRemark":{"totalCount":85,"edges":[{"node":{"excerpt":"1. V8为什么会有内存限制，原因是什么，如何解除？ V8限制堆的大小，分为两个层次的原因： 表层原因：是因为V8最终为浏览器设计，大内存使用场景无法遇到； 深层原因：是因为V8的垃圾回收机制限制。以1.5G的垃圾回收堆内存为例，一次小回收需要50ms以上，做一次非增量式的垃圾回收甚至要1s以上。垃圾回收过程JS线程暂停，应用性能和响应能力直线下降。限制是一个好选择（JAVA也有类似的设计）。 解除方式： 可以在Node启动的时候增加额外的启动参数调整old和new两个内存限制的大小：…","fields":{"slug":"/nodejs-cha-lou-bu-que-nei-cun-xiang-guan/"},"frontmatter":{"title":"Nodejs查漏补缺-内存相关","tags":["Node"],"star":false,"date":"17 Aug 2020","author":"烈风裘"}}},{"node":{"excerpt":"1. 新建Buffer会占用V8分配的内存吗？ 不会，Buffer属于堆外内存，不是V8分配的 2. Buffer的内存分配机制 Buffer对象类似数组，它的元素为16进制的两位数，即0到255的数值。其内存分配是在Node的C++层面实现的内存的申请，但是在JavaScript层面分配内存。Node采用了slab分配机制，以8KB为界限区分Buffer是大对象还是小对象。 小对象（<8KB）： 采用slab的机制进行预先申请和事后分配的策略。例如第一次分配一个1024字节的Buffer…","fields":{"slug":"/nodejs-cha-lou-bu-que-buffer-xiang-guan/"},"frontmatter":{"title":"Nodejs查漏补缺-Buffer相关","tags":["Node"],"star":false,"date":"16 Aug 2020","author":"烈风裘"}}},{"node":{"excerpt":"1. 从用户态发出异步I/O调用后，到回调函数被执行，中间发生了什么？ 因为Node中的异步I/O调用不是有开发者自己调用的。示例代码如下： 整个异步I/O的流程如下：  请求对象、I/O线程池、观察者、 事件循环 这四个共同构成了Node异步I/O模型的基本要素。大致流程： 创建FSReqWrap请求对象，包括传参、当前方法、回调函数等都在请求对象中； 将请求对象放入线程池中等待执行； 线程执行完毕后，将结果存储在请求对象中，通知IOCP 事件循环的观察者在每次Tick的执行中，调用IOCP…","fields":{"slug":"/nodejs-cha-lou-bu-que-yi-bu-xiang-guan/"},"frontmatter":{"title":"Nodejs查漏补缺-异步相关","tags":["Node"],"star":false,"date":"16 Aug 2020","author":"烈风裘"}}},{"node":{"excerpt":"1 请介绍一下node里的模块是什么？ Node中，每个文件模块都是一个对象，它的接口  定义如下： 所有的模块都是 Module 的实例。module.exports 的定义就在这里体现，默认是空对象！ 这里的module.js引用subModules.js文件，打印module.js中的的  变量的结果： 2. 我们知道node导出模块有两种方式，一种是 exports.xxx=xxx 和module.exports…","fields":{"slug":"/nodejs-cha-lou-bu-que-mo-kuai-xiang-guan/"},"frontmatter":{"title":"Nodejs查漏补缺-模块相关","tags":["Node"],"star":false,"date":"16 Aug 2020","author":"烈风裘"}}},{"node":{"excerpt":"背景 在现实生活中，存在实现一个目标有多种策略可供选择的情况，比如：出门旅行的多种目的地、乘车方式等；超市打折促销的方式；吃饭做菜时，土豆丝的多种做法等； 在软件开发过程中也会遇到此类问题（模式），当实现某个功能存在多种策略时，我们根据环境（Context）的不同，选择指定的策略。比如进行排序，有冒泡排序、选择排序、插入排序、二叉树排序等。 反例介绍 当代码中存在根据环境进行多重if-else…","fields":{"slug":"/design-patterns-strategy-patterns/"},"frontmatter":{"title":"设计模式「策略模式」","tags":["设计模式"],"star":false,"date":"04 Oct 2019","author":"烈风裘"}}},{"node":{"excerpt":"安装 全局安装，详情： 使用问题 cnpm是使用软连方式安装，所以在IDE使用时，会遇到两个问题： 某些 IDE 无法正确识别软链，会导致循环索引。  目录下同时存在软链，不方便查看。 第一点，安装 webstorm-disable-index 这个依赖包即可。 第二点，你可以在  配置： 在  配置  的  增加  即可。","fields":{"slug":"/cnpm-shi-yong-zong-jie/"},"frontmatter":{"title":"cnpm使用总结","tags":["未归档"],"star":false,"date":"22 Sep 2019","author":"烈风裘"}}},{"node":{"excerpt":"如何进行Nodejs版本管理 使用场景 一般来说，直接从 Node.js 官网下载对应的安装包，即可完成环境配置。 但在本地开发的时候，经常需要快速更新或切换版本。 社区有 nvm、n 等方案，我们推荐跨平台的 nvs。 如何安装 Linux / macOS 环境 通过 Git Clone 对应的项目即可。 注意，安装程序会在, , 或者  中写入命令，先保证这些文件是存在的！ Windows 环境 由于 Windows 环境配置比较复杂，所以 Windows…","fields":{"slug":"/ru-he-jin-hang-nodejs/"},"frontmatter":{"title":"如何进行Nodejs版本管理","tags":["未归档"],"star":false,"date":"22 Sep 2019","author":"烈风裘"}}},{"node":{"excerpt":"原版《CSS Secrets》是由 LEA VEROU 编写，主要介绍网页设计中比较经典的 CSS 实现方案及编写技巧。中文版由“CSS 魔法”翻译，在阅读过程中个人感觉翻译的还是很到位的，这里点个赞。 CSS Secrets: Better Solutions to Everyday Web Design Problems 这篇文章是对《CSS 揭秘》一书的总结，以思维导图的方式将书中脉络梳理出来，在过一遍书中知识点时做到查漏补缺。另外，通过一次梳理就记住 CSS…","fields":{"slug":"/css-jie-mi/"},"frontmatter":{"title":"CSS揭秘","tags":["CSS"],"star":true,"date":"21 Jul 2018","author":"烈风裘"}}},{"node":{"excerpt":"是一个 CSS 函数，它能创建一个在多个颜色之间根据已知路径进行线性渐变的图片。没错，是类型的图片，因此渐变函数无法应用于的场景，比如：background-color。  此外，没有内在维度、尺寸或者比例，它的具体尺寸将和对应元素尺寸匹配，如果希望创建能重复渐变的特性，可以使用函数。 线性渐变是如何合成的？ 我们需要清楚的一点是，linear-gradient 是一个 css…","fields":{"slug":"/guan-yu-linear-gradient-ni-xu/"},"frontmatter":{"title":"关于linear-gradient()你需要知道的事儿","tags":["CSS"],"star":false,"date":"13 Jul 2018","author":"烈风裘"}}},{"node":{"excerpt":"CommonJS 和 AMD 模块都只能在运行时才能确定模块导出的对象。因此运行时才能得到整个对象，也就无法做到静态优化。而 ES6 从语法层面支持模块功能，其设计初衷就是就是尽量的静态化，使得代码在编译时就能确定模块的依赖关系。 ES6 关于 Module 的介绍参考阮一峰的 ES6 教程：ECMAScript 6 入门-Module 的语法。下面是平时用到比较少的部分，使用时应该注意的地方。 ES6 模块使用时的注意点 模块转发时，当前模块不能使用转发的变量 default…","fields":{"slug":"/guan-yu-module/"},"frontmatter":{"title":"关于Module","tags":["设计模式"],"star":false,"date":"07 Jul 2018","author":"烈风裘"}}}]}},"pageContext":{"skip":0,"limit":10,"author":"烈风裘"}},"staticQueryHashes":["3240721340","63159454"]}