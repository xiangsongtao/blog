{"componentChunkName":"component---src-templates-author-page-js","path":"/author/烈风裘/4","result":{"data":{"authorJson":{"id":"烈风裘","bio":"一往无前, 直到云开雾散!","avatar":"/avatar/me.jpeg","cover":"/background/photo-1503197979108-c824168d51a8.jpeg","github":"https://github.com/xiangst0816","twitter":"","zhihu":"","weibo":"","facebook":"","website":"https://xiangst0816.github.io/blog/","location":"HangZhou, China"},"allAuthorJson":{"totalCount":2,"edges":[{"node":{"id":"烈风裘","avatar":"/avatar/me.jpeg"}},{"node":{"id":"WALL-E","avatar":"/avatar/cleaner.jpg"}}]},"site":{"siteMetadata":{"title":"Attila","cover":"/background/1.jpg","author":"@烈风裘","description":"Thoughts, stories and ideas.","keywords":["烈风裘的博客","X-Blog","Attila","Gatsby","前端成长记录"],"tagCover":"/background/5.jpg","archiveCover":"/background/escape-flight.png","siteUrl":"https://xiangst0816.github.io/blog","logo":"","navigation":true,"subscribe":true}},"otherAuthorsInfo":{"edges":[{"node":{"id":"WALL-E","avatar":"/avatar/cleaner.jpg","master":false}}]},"allMarkdownRemark":{"totalCount":85},"currentMarkdownRemark":{"totalCount":85,"edges":[{"node":{"excerpt":"1. ////这些对象的含义和区别? ，它表示浏览器的一个实例  对象还是 ECMAScript 中的  对象，因而所有全局变量和函数都是它的属性，且所有原生的构造 函数及其他函数也都存在于它的命名空间下 此外, 页面可能包含很多 frames  对象始终指向最外围的框架(frames)，也就是整个浏览器窗口  对象表示包含当前框架的框架，而 self 对象则回指  在没有框架的情况下， 一定等于 （此时它们都等于 ） 与框架有关的最后一个对象是 self…","fields":{"slug":"/di-ba-zhang-BOM/"},"frontmatter":{"title":"第八章 BOM","tags":["JS高程"],"star":false,"date":"28 Feb 2018","author":"烈风裘"}}},{"node":{"excerpt":"至少是我这里的前端开发都是自顶向下的模式, 即先按照支持程度最高的浏览器上开发, 之后再适配其他浏览器. 因此, 适配过程就需要对不同的客户端. 能力检测 H5 能力检测, 比如这个库: modernizr 怪癖检测(Bug 检测) 一般情况下不推荐使用. userAgent 检测 一般通过正则匹配 userAgent 进行平台鉴别. 例如: UAParser.js Lightweight JavaScript-based User-Agent String Parser","fields":{"slug":"/di-jiu-zhang-ke-hu-duan-jian-ce/"},"frontmatter":{"title":"第九章 客户端检测","tags":["JS高程"],"star":false,"date":"28 Feb 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. 对象定义? 无需属性的集合, 其属性可以包含基本值/对象/函数; 或者, 没有特定顺序的散列表. 或者, 使用 js 实现一个散列表?\n答: var a = {}; 2. 操作符执行的过程? 3. 下面的输出结果是? 4. 谈谈你对 prototype 的理解? 每个函数都有一个(原型)属性, 这个属性是一个指针, 指向 prototype 原型对象 prototype 原型对象的用途是包含可以由特定类型的所有实例共享的属性和方法 prototype…","fields":{"slug":"/di-liu-lu-zhang-mian-xiang-dui-xiang/"},"frontmatter":{"title":"第六章 面相对象的程序设计","tags":["JS高程"],"star":false,"date":"26 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. 下面代码返回什么, 位置 3~98 返回什么? 说明: array 类型的 length 属性不是只读的, 设置 length 可以对数组动态缩减及扩容. 可根据需要动态添加数据, length 自动叠加, 中间未定义的数据为 undefined 2. 数组复制的方法有哪些? 3. 不影响原值的情况下, 获取数组最后一个元素的方法有哪些? 4. 理解 Function, 实现方法的 polyfill…","fields":{"slug":"/di-wu-zhang-yin-yong-lei-xing/"},"frontmatter":{"title":"第五章 引用类型","tags":["JS高程"],"star":false,"date":"21 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"问答 1. 何为基本类型和引用类型? 基本类型: 简单的数据段, 类型如, undefined, null, boolean, string, number; 引用类型: 值保存在堆内存中的对象, 通过地址访问. 2. 函数传递参数时, 基础类型是按值传递/引用类型是按引用传递? 回答: 全部是按值传递!! 当在向参数传递引用类型的值时, 会把这个值在堆内存中的地址复制给一个局部变量. 可以把 ECMAScript…","fields":{"slug":"/di-si-zhang-bian-liang/"},"frontmatter":{"title":"第四章 变量-作用域和内存问题","tags":["JS高程"],"star":false,"date":"20 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"问答 1. 函数声明的语法是? 2. 函数表达式(匿名函数)的语法是? 3. 以下递归语句是否报错, 报错原因是? 如何改进? 错误: Uncaught TypeError: factorial is not a function 原因: 函数 factorial 内部的 factorial 指向 null, 因此报错. 方法 1: arguments.callee, 它指向当前正在执行的函数指针. 但是严格模式不允许使用. 方法 2: 函数表达式…","fields":{"slug":"/di-qi-zhang-han-shu-shuo-biao-da-shi/"},"frontmatter":{"title":"第七章 函数表达式","tags":["JS高程"],"star":false,"date":"08 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"写代码的时候经常用到，但是被问起却哑口无言，或者只能说到表面，这里再详细总结写，查漏补缺。 介绍 JavaScript…","fields":{"slug":"/bi-bao/"},"frontmatter":{"title":"闭包","tags":["JavaScript"],"star":false,"date":"01 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"就是下面这样的的代码： 关于 IIFE 书写方式 第一种情况： 解释：JavaScript 在解析代码时，当遇到关键字时，会默认把它当做一个函数声明，而不是函数表达式，如果没有把它显式的写成函数表达式，就报错，因为函数声明需要一个函数名。上面的报错是因为没有函数名(第一个左括号)。 第二种情况： 解释：在表达式后面加括号表示执行；此外，在函数声明一个语句，在语句后面加括号可等价为： 相当于声明了函数 foo…","fields":{"slug":"/IIFE-li-ji-zhi-hang-xing-han-shu-shuo/"},"frontmatter":{"title":"IIFE立即执行函数","tags":["JavaScript"],"star":false,"date":"01 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"这里说的变量提升指的是使用var声明的变量 变量提升也可以说是“变量声明前置”，就是把函数里面用到的变量声明提升到前面，赋值步骤在书写的位置进行。 是否使用 var 定义变量的区别 使用 var 定义的变量是函数级变量，只在函数内能访问到。 不使用 var 定义的变量是全局变量，等同于 块级作用域和函数级作用域 使用传统的定义的变量执行的是函数级作用域。 描述一下就是：在函数中使用定义的变量都会将变量声明放在函数的第一行，变量赋值在书写的位置赋值。 使用 let…","fields":{"slug":"/bian-liang-ti-di-sheng/"},"frontmatter":{"title":"变量提升","tags":["JavaScript"],"star":false,"date":"01 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"this 是什么 在函数运行时，基于调用位置的条件自动生成的内部对象，可以理解为动态绑定对象到 this 上。 需要强调的是： 只针对函数，在函数内部使用 this 由调用位置的上下文自动的决定，而不是函数声明的位置（代码书写的位置） 必须是运行时才确定，而不是编写时 this 绑定之后可理解为自动生成的内部对象 示例： this 的四个绑定规则及优先级 下面四个为 this 的绑定优先级规则，第一个优先级最高。判断执行流程需要做的就是找到函数的调用位置并判断使用哪条规则。…","fields":{"slug":"/guan-yu-this/"},"frontmatter":{"title":"关于this","tags":["JavaScript"],"star":false,"date":"30 Dec 2017","author":"烈风裘"}}}]}},"pageContext":{"skip":30,"limit":10,"author":"烈风裘"}},"staticQueryHashes":["3240721340","63159454"]}