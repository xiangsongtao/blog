{"componentChunkName":"component---src-templates-author-page-js","path":"/author/烈风裘/3","result":{"data":{"authorJson":{"id":"烈风裘","bio":"一往无前, 直到云开雾散!","avatar":"/avatar/me.jpeg","cover":"/background/photo-1503197979108-c824168d51a8.jpeg","github":"https://github.com/xiangsongtao","twitter":"","zhihu":"","weibo":"","facebook":"","website":"https://xiangsongtao.github.io/blog/","location":"HangZhou, China"},"allAuthorJson":{"totalCount":2,"edges":[{"node":{"id":"烈风裘","avatar":"/avatar/me.jpeg"}},{"node":{"id":"WALL-E","avatar":"/avatar/cleaner.jpg"}}]},"site":{"siteMetadata":{"title":"Attila","cover":"/background/1.jpg","author":"@烈风裘","description":"Thoughts, stories and ideas.","keywords":["烈风裘的博客","X-Blog","Attila","Gatsby","前端成长记录"],"tagCover":"/background/5.jpg","archiveCover":"/background/escape-flight.png","siteUrl":"https://xiangst0816.github.io/blog","logo":"","navigation":true,"subscribe":true}},"otherAuthorsInfo":{"edges":[{"node":{"id":"WALL-E","avatar":"/avatar/cleaner.jpg","master":false}}]},"allMarkdownRemark":{"totalCount":85},"currentMarkdownRemark":{"totalCount":85,"edges":[{"node":{"excerpt":"这里介绍的不是 SPA 和 PWA。 我觉得这可能是未来前后端分离的新方式，因为： 更快的页面显示 项目在构建时就能生成对应路由的静态页面，用户访问网页就能提前触发事件并渲染页面。这个在后面的一篇文章《SSR 相关》有介绍。  更方便的部署 前端项目骨架都静态化，因此资源可以走 CDN，这个没什么好说的。页面动态部分通过接口获取，可以使用 RESTAPI 也可以是 GraphQL。这样相对于传统的网页项目来说，静态化的方案可以大大节省服务器的资源。 解决方案成熟 1. React…","fields":{"slug":"/wu-fu-wu-duan-de/"},"frontmatter":{"title":"无服务端的自动静态化Web应用","tags":["静态化"],"star":false,"date":"22 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. 类型检测的方式有哪些, 使用场景是? 使用 typeof 检测基础类型 使用 instanceof 检测引用类型 使用 Object.prototype.toString.call(value)可以处理大部分情况 2. 如果类没有用关键字初始化一般会造成什么后果, 怎么避免? 在构造函数中的属性会污染全局变量, 可以在构造函数中通过判断下当前实例的构造函数是不是自己, 如果不是则使用方法返回. 3. 补充一个完整类继承及实例化的示例? 补充 Object.create 的 polyfill…","fields":{"slug":"/di-er-shi-er-zhang/"},"frontmatter":{"title":"第二十二章 高级技巧","tags":["JS高程"],"star":false,"date":"21 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. XMLHttpRequestd 对象发送请求的步骤, 使用和方法举例? 创建 xhr 实例 open 一个请求 设置 header send 请求 如果满足条件可以 abort get()同步示例: get()异步示例: post()示例: 注意点: 如果是相对路径, 则 URL 相对于执行代码的当前页面 调用**  方法并不会真正发送请求， 而只是启动一个请求以备发送** 调用  之后，请求就会被分派到服务器 通过来检测返回状态, responseText…","fields":{"slug":"/di-er-shi-yi-zhang/"},"frontmatter":{"title":"第二十一章 Ajax与Comet","tags":["JS高程"],"star":false,"date":"20 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. try-catch 在可能发生错误的地方使用 try-catch 语句 catch 中的 error 错误对象必须要写, 不可忽略 error.message: 错误消息 error.name: 错误名称 2. 下面包含语句的代码返回值时? finally 子句一经使用，其代码无论如何都会执行 如果 finally 包含 return, 则会忽略上面的所有 return 上例子中返回 0 3. 报错的 error 类型种类, 如何获取类型? Error: 基类错误 EvalError…","fields":{"slug":"/di-shi-qi-zhang-cuo/"},"frontmatter":{"title":"第十七章 错误处理及调试","tags":["JS高程"],"star":false,"date":"19 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. 如何判断在线状态? 属性: 事件: 2. manifest 应用缓存 看下 Gatsby 的实现. 书上说的和 Gatsby 实现的方式不一样. gatsby-plugin-offline gatsby-plugin-manifest 3. Cookie 相关 作用: 在客户端用于存储会话信息的 限制: 一个域下的所有 cookie 长度限制在 4095B(含)以内 每个域名下 cookie 个数不超过 50 个(一般最大) 每次请求会携带 cookie, 不建议存储大信息量 cookie…","fields":{"slug":"/di-er-shi-san-zhang/"},"frontmatter":{"title":"第二十三章 离线应用与客户端存储","tags":["JS高程"],"star":false,"date":"18 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. JSON 和 JavaScript 的关系? JSON 并不从属于 JavaScript JSON 是一种数据格式, 而不是编程语言 JSON 可表示的数据类型有: 对象/数组/字符串/数字/布尔值/null, 其余类型忽略. 2. 除了使用全局对象解析 JSON 还有什么方法? 问题点是? 还有方法可以解析, 问题点是: 中可能有恶意代码 性能不高 支持的的浏览器, IE8+ 3. 时的注意点? 不能保存函数, 如果有函数会忽略 值为会被忽略…","fields":{"slug":"/di-20-zhang-json/"},"frontmatter":{"title":"第二十章 JSON","tags":["JS高程"],"star":false,"date":"18 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"这里所说的事件是指: JavaScript 和 HTML 之间交互的事件. 也就是说, 浏览器文档在交互的过程中会以事件的方式通知绑定的监听器. 这里使用了传统软件工程的观察者模式的设计模型, 实现JavaScript与文档(HTML/CSS)之间的解耦. 1. 事件流理解? 事件流描述的是从页面中接收事件的顺序. “DOM2 级事件” 规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 目标阶段是冒泡阶段的一部分.…","fields":{"slug":"/di-shi-san-zhang-shi-jian/"},"frontmatter":{"title":"第十三章 事件","tags":["JS高程"],"star":false,"date":"05 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. 为什么属性获取到的样式信息不全? 这个 style 对象 是 CSSStyleDeclaration 的实例，包含着通过 HTML 的 style 特性指定的所有样式信息，但不包含与外部样式表或嵌入样式表经层叠而来的样式。 不同方式定义的样式(//在元素上定义)是有差异的!!! 使用可以获取包含当前元素的所有计算的样式. 方法接收两个参数: 要取得计算样式的元素和一个伪元素字符串（例如”:after”） 注意综合属性的返回值, 比如 border…","fields":{"slug":"/di-shi-er-zhang-DOM2-he-huo-hu-DOM3/"},"frontmatter":{"title":"第十二章 DOM2和DOM3","tags":["JS高程"],"star":false,"date":"05 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. DOM 选择符 API 根据 CSS 选择符 选择与某个模式匹配的 DOM 元素.  IE8+, 返回第一个匹配的 Node  IE8+, 返回 NodeList  IE9+, 如果调用元素与该选择符匹配，返回 true；否则，返回 false。 这个 API 并未全部支持, 可用下面方式使用: 2. ElementNode 类型 Node 查询增强 API childElementCount：返回子元素（不包括文本节点和注释）的个数。 firstElementChild…","fields":{"slug":"/di-shi-yi-zhang-DOM-tuo-ta-zhi-zhan/"},"frontmatter":{"title":"第十一章 DOM拓展","tags":["JS高程"],"star":false,"date":"04 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. 对 DOM 树形结构的理解? DOM 解释 DOM(文档对象模型), 是针对类 HTML 层次化节点树操作的一个API(应用程序编程接口)集合. 用于更改底层文档及外观结构. 根节点 树中的节点可以由多种Node 类型组成, 根节点称之为文档元素(传说的), 即. Node 类型 类型可以是: Node.ELEMENT_NODE(1)；子元素 Node.ATTRIBUTE_NODE(2)； Node.TEXT_NODE(3)； 文本 Node.CDATASECTIONNODE(…","fields":{"slug":"/di-shi-zhang-DOM/"},"frontmatter":{"title":"第十章 DOM","tags":["JS高程"],"star":false,"date":"04 Mar 2018","author":"烈风裘"}}}]}},"pageContext":{"skip":20,"limit":10,"author":"烈风裘"}},"staticQueryHashes":["3240721340","63159454"]}