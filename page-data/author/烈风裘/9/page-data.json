{"componentChunkName":"component---src-templates-author-page-js","path":"/author/烈风裘/9","result":{"data":{"authorJson":{"id":"烈风裘","bio":"一往无前, 直到云开雾散!","avatar":"/avatar/me.jpeg","cover":"/background/photo-1503197979108-c824168d51a8.jpeg","github":"https://github.com/xiangst0816","twitter":"","zhihu":"","weibo":"","facebook":"","website":"https://xiangst0816.github.io/blog/","location":"HangZhou, China"},"allAuthorJson":{"totalCount":2,"edges":[{"node":{"id":"烈风裘","avatar":"/avatar/me.jpeg"}},{"node":{"id":"WALL-E","avatar":"/avatar/cleaner.jpg"}}]},"site":{"siteMetadata":{"title":"Attila","cover":"/background/1.jpg","author":"@烈风裘","description":"Thoughts, stories and ideas.","keywords":["烈风裘的博客","X-Blog","Attila","Gatsby","前端成长记录"],"tagCover":"/background/5.jpg","archiveCover":"/background/escape-flight.png","siteUrl":"https://xiangst0816.github.io/blog","logo":"","navigation":true,"subscribe":true}},"otherAuthorsInfo":{"edges":[{"node":{"id":"WALL-E","avatar":"/avatar/cleaner.jpg","master":false}}]},"allMarkdownRemark":{"totalCount":85},"currentMarkdownRemark":{"totalCount":85,"edges":[{"node":{"excerpt":"本总结是对《高性能 JavaScript》这本书的总结也是记录笔记,加深我对 JavaScript 的认识及实践技巧。 一、脚本的加载和执行 一般来说，JavaScript 代码的执行会阻塞浏览器进行的其他程序，比如用户界面绘制。每次遇到后，,页面都必须停下来等待代码下载并执行，然后再继续解析和渲染页面。在这期间，页面渲染和用户交互是完全被阻塞的，例如页面出现长时间的白屏。解决方案如下： 将放在之前，确保脚被执行前页面已完成渲染。 标签越少越好，可以考虑用 gulp 任务合并。因为 HTTP…","fields":{"slug":"/gao-xing-neng-nai-JavaScript-shi-jian/"},"frontmatter":{"title":"高性能JavaScript实践总结","tags":["JavaScript","读书笔记"],"star":false,"date":"21 May 2016","author":"烈风裘"}}},{"node":{"excerpt":"我这是用的是这个插件jquery.lazyload.js,关于介绍也很多了,我这里就只见上干货，就说怎么用开始，不过还是先介绍下他是干什么的，怎么干的。 1. 做什么的 图片延迟加载，等滚到图片的位置时才加载，后面的图片先不加载，故能避免卡顿，需要加载图片的时候，图片进行下载，等加载完毕后才出现，消除出现半幅图的情况（改善用户体验） 2. 怎么干的 data-original:这个是真正要交加载的图片； src：这个是占位图片，默认是 grey.gif，高度只有 1px…","fields":{"slug":"/imgLazyloadJS/"},"frontmatter":{"title":"imgLazyloadJS","tags":["JavaScript"],"star":false,"date":"10 Dec 2015","author":"烈风裘"}}},{"node":{"excerpt":"第一次看官网的说明真是一头雾水,再次学习的时候感觉思路清晰很多,因此在这总结. 为什么使用 requirejs? 下面是我认为的原因: 代码逻辑复杂需要模块化管理; 在 js 文件中引入其他 js 文件的代码只能通过标签 提升网页打开速度需要减少调用外部的 js 标签 接下来我就从怎么使用开始吧. 需要在 html 代码中添加 requirejs 的标签 两种方式都行:   将标签添加在的末尾 指定 js 文件的主入口位置 指定文件位置 配置 main.js 文件 定义模块 sub.js…","fields":{"slug":"/RequireJS/"},"frontmatter":{"title":"RequireJS","tags":["RequireJS"],"star":false,"date":"10 Dec 2015","author":"烈风裘"}}},{"node":{"excerpt":"1.spanjs 插件使用(菊花) 显示效果（无限菊花）： 菊花状 快速开始： -. HTML 页面插入代码 -. 设置菊花的参数 -. 调用函数 -. 停止 -. 再开始 2.CProgressjs 插件(菊花+进度值) 显示效果: 菊花+进度值 可固定值,也可修改 limit value(终点值). 快速开始 -. HTML 页面插入代码 -. 设置菊花的参数并启动 -. myplugin 的其余方法 -. CSS 配置\n/显示圆形进度的外层 div,自动创建的 div…","fields":{"slug":"/jin-du-duo-xian-shi/"},"frontmatter":{"title":"进度显示","tags":["插件"],"star":false,"date":"11 Nov 2015","author":"烈风裘"}}},{"node":{"excerpt":"跨域访问: 如果我们希望获取的数据和当前页面并不是一个域，著名的同源策略（不同域的客户端脚本在没明确授权的情况下，不能读写对方的资源）会因为安全原因决绝请求，也就是我们不能向其它域直接发送请求以获取资源。 iframe、img、style、script 等元素的 src 属性可以直接向不同域请求资源，jsonp 正是利用 script 标签跨域请求资源的 异域服务器的 php 代码: 将 xml 数据转化成 json,之后将传入的 callback 的值作为函数名传入 json…","fields":{"slug":"/JSONP-kua-yu-fang-wen-fu-wu/"},"frontmatter":{"title":"JSONP跨域访问服务","tags":["JSONP"],"star":false,"date":"11 Nov 2015","author":"烈风裘"}}}]}},"pageContext":{"skip":80,"limit":10,"author":"烈风裘"}},"staticQueryHashes":["3240721340","63159454"]}