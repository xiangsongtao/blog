{"componentChunkName":"component---src-templates-blog-post-js","path":"/Manifest-de-di-shi-yong/","result":{"data":{"site":{"siteMetadata":{"title":"Attila","cover":"/background/1.jpg","description":"Thoughts, stories and ideas.","keywords":["烈风裘的博客","X-Blog","Attila","Gatsby","前端成长记录"],"tagCover":"/background/5.jpg","archiveCover":"/background/escape-flight.png","siteUrl":"https://xiangst0816.github.io/blog","logo":"","navigation":true,"subscribe":true}},"allAuthorJson":{"totalCount":2,"edges":[{"node":{"id":"烈风裘","bio":"一往无前, 直到云开雾散!","avatar":"/avatar/avatar.jpeg","cover":"/background/photo-1503197979108-c824168d51a8.jpeg","github":"https://github.com/xiangst0816","twitter":"","zhihu":"","weibo":"","facebook":"","website":"https://xiangst0816.github.io/blog/","location":"HangZhou, China"}},{"node":{"id":"WALL-E","bio":"还有要清理的吗?","avatar":"/avatar/cleaner.jpg","cover":"","github":null,"twitter":null,"zhihu":null,"weibo":null,"facebook":null,"website":null,"location":"Earth"}}]},"master":{"id":"烈风裘","bio":"一往无前, 直到云开雾散!","avatar":"/avatar/avatar.jpeg","cover":"/background/photo-1503197979108-c824168d51a8.jpeg","github":"https://github.com/xiangst0816","twitter":"","zhihu":"","weibo":"","facebook":"","website":"https://xiangst0816.github.io/blog/","location":"HangZhou, China"},"currentPost":{"html":"<p>为了加快网页的访问速度，对请求资源进行缓存是一个常用的策略。当客户端发送资源请求后，如果资源未过期，则服务器返回 304 代表资源未修改使用浏览器本地缓存，但是这个过程还是会发生 TCP 连接，如果不发送请求就能知道本地的缓存副本就是最新的按就好了。</p>\n<p>其中的一个解决方案就是使用 HTML5 的最新特性离线存储(manifest)来解决。通过离线存储，我们可以通过把需要离线存储在本地的文件列在一个 manifest 配置文件中，这样即使在离线的情况下，用户也可以正常使用 App。同时，由之前返回的 304(not modified)全部变成 200(from cache)，也即是说不用再请求服务器资源了。</p>\n<blockquote>\n<p>PS：应该是在单页面 SPA 应用中多使用此技术，除了 IE9 及其以下版本不兼容，其余浏览器都兼容。</p>\n</blockquote>\n<h3 id=\"怎么使用\" style=\"position:relative;\"><a href=\"#%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8\" aria-label=\"怎么使用 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>怎么使用</h3>\n<p>在 html 中加入 manifest 的属性就可以了。</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">DOCTYPE</span> <span class=\"token name\">HTML</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">manifest</span> <span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span> <span class=\"token punctuation\">\"</span>cache.manifest<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n...\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>之后编写<code class=\"language-text\">cache.manifest</code>文件(此文件一般是通过自动化工具来做生成，手动维护很痛苦)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CACHE MANIFEST\n\nCACHE:\nhttp://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css\nhttp://cdn.bootcss.com/font-awesome/4.6.3/fonts/fontawesome-webfont.woff2?v=4.6.3\nhttp://xiangsongtao.com/static/css/app.40ca310ea17e37e2c7d1be290f097782.css\nhttp://xiangsongtao.com/static/js/0.cc35128bd8494c03daa0.js\nhttp://xiangsongtao.com/static/js/1.9f1833ed33a94fe44f61.js\nhttp://xiangsongtao.com/static/js/2.6fd53cc0491419739c75.js\nhttp://xiangsongtao.com/static/js/3.7d2782ebd4a9ccfc73c3.js\nhttp://xiangsongtao.com/static/js/4.3ffed0ad00e3cbf19311.js\nhttp://xiangsongtao.com/static/js/5.0864b0b318aed8c5e5c3.js\nhttp://xiangsongtao.com/static/js/6.8cf1f468ef4e49b1fb0d.js\nhttp://xiangsongtao.com/static/js/7.da83992afd496d4889e3.js\nhttp://xiangsongtao.com/static/js/8.a75be465a534de6bc590.js\nhttp://xiangsongtao.com/static/js/app.88635de0da664917c9bc.js\nhttp://xiangsongtao.com/static/js/manifest.c3d7bc712610ce511e9b.js\nhttp://xiangsongtao.com/static/js/vendor.dd1992f099a201029616.js\n\nNETWORK:\n*\n\nSETTINGS:\nprefer-online\n\n# hash: f98a3b3dac77c6644dc0795a6fb7e44ca03f41b33ff6d738d3da57b783abf5f1\n\nFALLBACK:\n/ /offline.html</code></pre></div>\n<p>SETTINGS 可以设置成两种模式，默认是 fast。但是在我的测试中没感觉到这两种模式有什么区别，这个就暂时不说了。</p>\n<p>这些就是 manifest 缓存最基本的东西，还有一个很大的问题就是火狐的警告。当使用 manifest 时，火狐下会出现警告。</p>\n<p>生成上述 manifest 文件的 gulp 配置如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&#39;use strict&#39;;\nvar  gulp  = require(&#39;gulp&#39;);\nvar  gulpLoadPlugins  = require(&#39;gulp-load-plugins&#39;);\nvar $ = gulpLoadPlugins();\n\ngulp.task(&#39;manifest&#39;, function(){\n  gulp.src([&#39;dist/static/**/*.{js,css}&#39;], { base: &#39;./dist&#39; })\n    .pipe($.manifest({\n      hash: true,\n      preferOnline: true,\n      prefix:&#39;http://xiangsongtao.com/&#39;,\n      network: [&#39;*&#39;],\n      cache:[\n        &#39;http://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css&#39;,\n        &#39;http://cdn.bootcss.com/font-awesome/4.6.3/fonts/fontawesome-webfont.woff2?v=4.6.3&#39;,\n      ],\n      filename: &#39;app.manifest&#39;,\n      exclude: [&#39;app.manifest&#39;]\n    }))\n    .pipe(gulp.dest(&#39;dist&#39;));\n});</code></pre></div>\n<h3 id=\"manifest-解析过程\" style=\"position:relative;\"><a href=\"#manifest-%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B\" aria-label=\"manifest 解析过程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>manifest 解析过程</h3>\n<p>在线情况第一次访问，则查找 html 中的 manifest 文件，如果有则下载里面需要缓存的资源。第二次访问的时候，浏览器使用本地缓存副本渲染网页，之后判断 manifest 中的文件是否更新，如果未更新则不操作；如果已更新，则下载最新副本缓存（也就是说，更新 manifest 后并不会立即生效，需要再刷新下）,这个问题我们可以用代码进行手动缓存的刷新解决，调用<code class=\"language-text\">window.applicationCache.update()</code>进行缓存刷新，<code class=\"language-text\">window.applicationCache.swapCache()</code>进行重新请求更新的资源进行渲染。</p>\n<h3 id=\"manifest-过程对应的事件\" style=\"position:relative;\"><a href=\"#manifest-%E8%BF%87%E7%A8%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BA%8B%E4%BB%B6\" aria-label=\"manifest 过程对应的事件 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>manifest 过程对应的事件</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> window.applicationCache.onnoupdate = function(){\n            console.debug(&#39;onnoupdate!!!!&#39;)\n}</code></pre></div>\n<ol>\n<li>oncached:当离线资源存储完成之后触发这个事件，这个是文档的说法，我在 Chrome 上面测试的时候并没有触发这个事件（onobsolete 也是）。</li>\n<li>onchecking:当浏览器对离线存储资源进行更新检查的时候会触发这个事件</li>\n<li>ondownloading:当浏览器开始下载离线资源的时候会触发这个事件</li>\n<li>onprogress:当浏览器在下载每一个资源的时候会触发这个事件，每下载一个资源就会触发一次。</li>\n<li>onupdateready:当浏览器对离线资源更新完成之后会触发这个事件</li>\n<li>on 中 noupdate:当浏览器检查更新之后发现没有资源更新的时候触发这个事件</li>\n<li>onerror: 当 manifest 中缓存的资源下载错误是触发</li>\n</ol>\n<h3 id=\"manifest-使用场景\" style=\"position:relative;\"><a href=\"#manifest-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\" aria-label=\"manifest 使用场景 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>manifest 使用场景</h3>\n<p>manifest 的名字叫 Application Cache 就已经很好的定性了，它是用来构造离线应用程序的。比方说你写了个秒表，它离线也能用，这是 manifest 的应用场景。它会讲当前访问的 HTML 也缓存起来，故实时的 web 还是别用了。</p>\n<p>如果要缓存资源，设置<code class=\"language-text\">Cache Control</code>和<code class=\"language-text\">Expires</code>来做吧，这个见我的另外一篇文章。</p>\n<h3 id=\"参考资源\" style=\"position:relative;\"><a href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90\" aria-label=\"参考资源 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参考资源</h3>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/gulp-manifest\" target=\"_target\" rel=\"nofollow\">Gulp-manifest</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000000732617\" target=\"_target\" rel=\"nofollow\">原文参考 1</a></li>\n<li><a href=\"http://bin-playground.top\" target=\"_target\" rel=\"nofollow\">原文参考 2</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache\" target=\"_target\" rel=\"nofollow\">Using<em>the</em>application_cache</a></li>\n<li><a href=\"http://diveintohtml5.info/offline.html\" target=\"_target\" rel=\"nofollow\">LET’S TAKE THIS OFFLINE</a></li>\n</ul>","timeToRead":5,"wordCount":{"paragraphs":28,"sentences":28,"words":152},"fields":{"slug":"/Manifest-de-di-shi-yong/","relativePath":"2016/2016-10-20---Manifest-de-di-shi-yong/index.md"},"excerpt":"为了加快网页的访问速度，对请求资源进行缓存是一个常用的策略。当客户端发送资源请求后，如果资源未过期，则服务器返回 304 代表资源未修改使用浏览器本地缓存，但是这个过程还是会发生 TCP…","frontmatter":{"title":"Manifest的使用","date":"20 Oct 2016","tags":["缓存"],"cover":"","comments":true,"author":"烈风裘"}},"nextPost":{"html":"<p>思考这个问题主要是有人问到过我：用户登录的密码是如何保护的，又是如何在网络传输下让黑客看到也拿破解不了用户密码，也无法再次模拟登录？</p>\n<p>好吧，一个是将密码使用 MD5 加密传输，另一个是使用 HTTPs 协议。</p>\n<p>对于我这个小网站，用 HTTPs 有些大题小做，那如果不用 HTTPs 呢？</p>\n<h3 id=\"登录设计\" style=\"position:relative;\"><a href=\"#%E7%99%BB%E5%BD%95%E8%AE%BE%E8%AE%A1\" aria-label=\"登录设计 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>登录设计</h3>\n<p>对此我想了下设计了下面登录方式（时序图）：</p>\n<p><img src=\"http://xiangsongtao.com/uploads/1476276752000.png\" alt=\"登录时序图\"></p>\n<h3 id=\"过程分析\" style=\"position:relative;\"><a href=\"#%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90\" aria-label=\"过程分析 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>过程分析</h3>\n<ol>\n<li>用户发起登录请求</li>\n<li>服务器根据用户 IP 及服务器时间，返回上图所写的格式数据。将当前请求信息用 MD5 包裹</li>\n<li>客户端用服务器返回的数据发送用户名<code class=\"language-text\">u</code>和密码<code class=\"language-text\">p</code>，其中密码用 MD5 包裹</li>\n<li>最后由服务器判断当前请求的结果：服务器分析用户的 IP、判断发起登录的时间（允许登录的时间窗口为 5s，超时就失败）、判断密码的 MD5 值。</li>\n</ol>\n<h3 id=\"hack-分析\" style=\"position:relative;\"><a href=\"#hack-%E5%88%86%E6%9E%90\" aria-label=\"hack 分析 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hack 分析</h3>\n<ol>\n<li>除非 Hack 就在在用户输入的时候就知道密码，否则他在中间任何一步拦截，都无法获取用户密码</li>\n<li>因为每次发送的密码盐<code class=\"language-text\">b</code>都不一样，即使 Hack 伪造，也无法再次<strong>同时同地</strong>的使用。</li>\n</ol>\n<h3 id=\"博客改造\" style=\"position:relative;\"><a href=\"#%E5%8D%9A%E5%AE%A2%E6%94%B9%E9%80%A0\" aria-label=\"博客改造 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>博客改造</h3>\n<p>按照上面设计的方法进行登录改造,避免登录传输明文 password 的问题, 并且对登录后的 token 重点关键信息进行了 md5 修改. 整个前后台修改不到 2h, 很快哈.</p>\n<p>这里使用的 md5 工具是<code class=\"language-text\">js-md5</code>, <a href=\"https://www.npmjs.com/package/js-md5\" target=\"_target\" rel=\"nofollow\">详细链接在这里</a>.</p>\n<p>修改后的信息见我的博客登录处, 你可以尝试不用的输入,观察发送的结果及后台返回的结果.</p>\n<p>（完）</p>","timeToRead":2,"wordCount":{"paragraphs":19,"sentences":20,"words":80},"fields":{"slug":"/deng-lu-liu-cheng-jia-mi-de-di-si-sai-kao/","relativePath":"2016/2016-10-20---deng-lu-liu-cheng-jia-mi-de-di-si-sai-kao/index.md"},"excerpt":"思考这个问题主要是有人问到过我：用户登录的密码是如何保护的，又是如何在网络传输下让黑客看到也拿破解不了用户密码，也无法再次模拟登录？ 好吧，一个是将密码使用 MD5 加密传输，另一个是使用 HTTPs…","frontmatter":{"title":"登录流程加密的思考","date":"20 Oct 2016","tags":["随笔"],"cover":"","comments":true,"author":"烈风裘"}},"prevPost":{"html":"<p>相信这样的代码<code class=\"language-text\">setTimeout(function () {},0)</code>我们都是遇到过的, 但是思考为什么这么用而不用其他的办法的人估计就很少了，今天遇到，在此记录。</p>\n<h2 id=\"先解释下-javascript-单线程模型\" style=\"position:relative;\"><a href=\"#%E5%85%88%E8%A7%A3%E9%87%8A%E4%B8%8B-javascript-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B\" aria-label=\"先解释下 javascript 单线程模型 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>先解释下 JavaScript 单线程模型</h2>\n<p><a href=\"http://www.cnblogs.com/silin6/p/4333999.html\" target=\"_target\" rel=\"nofollow\">原文由此进入</a></p>\n<p>首先我们来看浏览器下的 JavaScript：</p>\n<p>浏览器的内核是多线程的，它们在内核制控下相互配合以保持同步，一个浏览器至少实现三个常驻线程：<strong>JavaScript 引擎线程</strong>，<strong>GUI 渲染线程</strong>，<strong>浏览器事件触发线程</strong>。</p>\n<ul>\n<li>JavaScript 引擎是基于事件驱动单线程执行的，JS 引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个 JS 线程在运行 JS 程序。</li>\n<li>GUI 渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。但需要注意 GUI 渲染线程与 JS 引擎是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。<a href=\"\">如何触发重绘操作</a></li>\n<li>事件触发线程，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可来自 JavaScript 引擎当前执行的代码块如<code class=\"language-text\">setTimeOut</code>、也可来自浏览器内核的其他线程如<code class=\"language-text\">鼠标点击事件</code>、<code class=\"language-text\">AJAX异步请求</code>等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。（当线程中没有执行任何同步代码的前提下才会执行异步代码）。<a href=\"\">事件</a></li>\n</ul>\n<p>js 的单线程在这一段面试代码中尤为明显（理解即可，请不要尝试…浏览器会假死的）：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var isEnd = true;\nwindow.setTimeout(function () {\n    isEnd = false; //1s后，改变isEnd的值\n}, 1000);\n//这个while永远的占用了js线程，所以setTimeout里面的函数永远不会执行\nwhile (isEnd);\n//alert也永远不会弹出\nalert(&#39;end&#39;);</code></pre></div>\n<p>在我工作中对 js 的认识，个人认为 js 的任务单位是<strong>函数</strong>。即，一个函数表示着一个任务，这个函数没有执行结束，则在浏览器中当前的任务即没有结束。</p>\n<p>上面的代码中，当前任务因为 while 的执行而造成永远无法执行，所以后面的 setTimeout 也永远不会被执行。它在浏览器的任务队列中如图所示：</p>\n<p><img src=\"http://xiangsongtao.com/uploads/1474859133000.png\"></p>\n<blockquote>\n<p>另外值得一提的是，setTimeout 会将内部 Fn 所需的执行环境保存挂载任务的末尾，因此如果 setTimeout 过多，在 node 端会造成内存泄露，因此在 node 端慎用。</p>\n</blockquote>\n<h2 id=\"实现-javascript-的异步；\" style=\"position:relative;\"><a href=\"#%E5%AE%9E%E7%8E%B0-javascript-%E7%9A%84%E5%BC%82%E6%AD%A5%EF%BC%9B\" aria-label=\"实现 javascript 的异步； permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>实现 javascript 的异步；</h2>\n<blockquote>\n<p>javascript 异步表示 async，指：代码执行不按顺序，‘跳过’执行，待其他某些代码执行完后，再来执行，称为“异步”。\njavascript 同步表示 sync，指：代码依次执行。</p>\n</blockquote>\n<p>当然，这个‘异步’是模拟的形式出现的。正常情况下 javascript 都是按照顺序执行的。但是我们可能让该语句后面的语句执行完再执行本身，这时就可以用到 setTimeout 延时 0ms 来实现了，将 setTimeout 内部函数放到同步函数的外面执行（<strong>setTimeout 内部函数放到了当前执行函数的外面</strong>）。如：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">alert(1);\nsetTimeout(&quot;alert(2)&quot;, 0);\nalert(3);</code></pre></div>\n<p>虽然延时了 0ms,但是执行顺序为：1，3，2\n这样就保证 setTimeout 里面的语句在某一代码段中最后执行。</p>\n<p>因此：<strong>我们应该认识到，利用 setTimeout(fn,0)的特性，可以帮助我们在某些极端场景下，修正浏览器的下一个任务。</strong></p>\n<p>（完）</p>","timeToRead":3,"wordCount":{"paragraphs":18,"sentences":19,"words":161},"fields":{"slug":"/setTimeout-yan-shi-0-hao-miao-de/","relativePath":"2016/2016-10-20---setTimeout-yan-shi-0-hao-miao-de/index.md"},"excerpt":"相信这样的代码我们都是遇到过的, 但是思考为什么这么用而不用其他的办法的人估计就很少了，今天遇到，在此记录。 先解释下 JavaScript 单线程模型 原文由此进入 首先我们来看浏览器下的 JavaScript…","frontmatter":{"title":"setTimeout延时0毫秒的作用","date":"20 Oct 2016","tags":["JavaScript"],"cover":"","comments":true,"author":"烈风裘"}}},"pageContext":{"curr":"/Manifest-de-di-shi-yong/","prev":"/setTimeout-yan-shi-0-hao-miao-de/","next":"/deng-lu-liu-cheng-jia-mi-de-di-si-sai-kao/"}},"staticQueryHashes":["3240721340","63159454"]}