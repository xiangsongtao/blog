{"componentChunkName":"component---src-templates-blog-post-js","path":"/deng-lu-liu-cheng-jia-mi-de-di-si-sai-kao/","result":{"data":{"site":{"siteMetadata":{"title":"Attila","cover":"/background/1.jpg","description":"Thoughts, stories and ideas.","keywords":["烈风裘的博客","X-Blog","Attila","Gatsby","前端成长记录"],"tagCover":"/background/5.jpg","archiveCover":"/background/escape-flight.png","siteUrl":"https://xiangst0816.github.io/blog","logo":"","navigation":true,"subscribe":true}},"allAuthorJson":{"totalCount":2,"edges":[{"node":{"id":"烈风裘","bio":"一往无前, 直到云开雾散!","avatar":"/avatar/me.jpeg","cover":"/background/photo-1503197979108-c824168d51a8.jpeg","github":"https://github.com/xiangst0816","twitter":"","zhihu":"","weibo":"","facebook":"","website":"https://xiangst0816.github.io/blog/","location":"HangZhou, China"}},{"node":{"id":"WALL-E","bio":"还有要清理的吗?","avatar":"/avatar/cleaner.jpg","cover":"","github":null,"twitter":null,"zhihu":null,"weibo":null,"facebook":null,"website":null,"location":"Earth"}}]},"master":{"id":"烈风裘","bio":"一往无前, 直到云开雾散!","avatar":"/avatar/me.jpeg","cover":"/background/photo-1503197979108-c824168d51a8.jpeg","github":"https://github.com/xiangst0816","twitter":"","zhihu":"","weibo":"","facebook":"","website":"https://xiangst0816.github.io/blog/","location":"HangZhou, China"},"currentPost":{"html":"<p>思考这个问题主要是有人问到过我：用户登录的密码是如何保护的，又是如何在网络传输下让黑客看到也拿破解不了用户密码，也无法再次模拟登录？</p>\n<p>好吧，一个是将密码使用 MD5 加密传输，另一个是使用 HTTPs 协议。</p>\n<p>对于我这个小网站，用 HTTPs 有些大题小做，那如果不用 HTTPs 呢？</p>\n<h3 id=\"登录设计\" style=\"position:relative;\"><a href=\"#%E7%99%BB%E5%BD%95%E8%AE%BE%E8%AE%A1\" aria-label=\"登录设计 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>登录设计</h3>\n<p>对此我想了下设计了下面登录方式（时序图）：</p>\n<p><img src=\"http://xiangsongtao.com/uploads/1476276752000.png\" alt=\"登录时序图\"></p>\n<h3 id=\"过程分析\" style=\"position:relative;\"><a href=\"#%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90\" aria-label=\"过程分析 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>过程分析</h3>\n<ol>\n<li>用户发起登录请求</li>\n<li>服务器根据用户 IP 及服务器时间，返回上图所写的格式数据。将当前请求信息用 MD5 包裹</li>\n<li>客户端用服务器返回的数据发送用户名<code class=\"language-text\">u</code>和密码<code class=\"language-text\">p</code>，其中密码用 MD5 包裹</li>\n<li>最后由服务器判断当前请求的结果：服务器分析用户的 IP、判断发起登录的时间（允许登录的时间窗口为 5s，超时就失败）、判断密码的 MD5 值。</li>\n</ol>\n<h3 id=\"hack-分析\" style=\"position:relative;\"><a href=\"#hack-%E5%88%86%E6%9E%90\" aria-label=\"hack 分析 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hack 分析</h3>\n<ol>\n<li>除非 Hack 就在在用户输入的时候就知道密码，否则他在中间任何一步拦截，都无法获取用户密码</li>\n<li>因为每次发送的密码盐<code class=\"language-text\">b</code>都不一样，即使 Hack 伪造，也无法再次<strong>同时同地</strong>的使用。</li>\n</ol>\n<h3 id=\"博客改造\" style=\"position:relative;\"><a href=\"#%E5%8D%9A%E5%AE%A2%E6%94%B9%E9%80%A0\" aria-label=\"博客改造 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>博客改造</h3>\n<p>按照上面设计的方法进行登录改造,避免登录传输明文 password 的问题, 并且对登录后的 token 重点关键信息进行了 md5 修改. 整个前后台修改不到 2h, 很快哈.</p>\n<p>这里使用的 md5 工具是<code class=\"language-text\">js-md5</code>, <a href=\"https://www.npmjs.com/package/js-md5\" target=\"_target\" rel=\"nofollow\">详细链接在这里</a>.</p>\n<p>修改后的信息见我的博客登录处, 你可以尝试不用的输入,观察发送的结果及后台返回的结果.</p>\n<p>（完）</p>","timeToRead":2,"wordCount":{"paragraphs":19,"sentences":20,"words":80},"fields":{"slug":"/deng-lu-liu-cheng-jia-mi-de-di-si-sai-kao/","relativePath":"2016/2016-10-20---deng-lu-liu-cheng-jia-mi-de-di-si-sai-kao/index.md"},"excerpt":"思考这个问题主要是有人问到过我：用户登录的密码是如何保护的，又是如何在网络传输下让黑客看到也拿破解不了用户密码，也无法再次模拟登录？ 好吧，一个是将密码使用 MD5 加密传输，另一个是使用 HTTPs…","frontmatter":{"title":"登录流程加密的思考","date":"20 Oct 2016","tags":["随笔"],"cover":"","comments":true,"author":"烈风裘"}},"nextPost":{"html":"<p>转载这篇文章,文章里面内容就不再展开，感兴趣的可以看下，<a href=\"http://www.cnblogs.com/vans/p/4550356.html\" target=\"_target\" rel=\"nofollow\">地址点击这里</a>。</p>\n<p>下面是我的评价：</p>\n<p>文章里说的都是基础，有些实际应用中的问题如果基础比较好的话能够深挖问题背后的原因，方便解决问题。我觉得基础是一个内化的过程，而不是背诵的过程。遇到问题深挖一下，然后在琢磨下背后的原理，这样比背诵的效果会好很多。比如，这样问应聘者：</p>\n<blockquote>\n<p>问：每天早上一打开网页就出现电信在右下角的小广告，需求说要避免这种情况，你该如何处理？</p>\n</blockquote>\n<blockquote>\n<p>答： 1. 如果特征相同的话，插入到 html 中的代码应该都是 ifream 结构的，页面加载的同时用 js 检查页面中是否有不属于页面的东西，如果有则<code class=\"language-text\">history.go(0)</code>处理；2. 另外一种更保险的方式是用 https 加密传输 html 内容，但是会 ssl 加解密通信会增加页面打开时间，建议再使用 http2.0 的方式请求，这样只建立一次 TCP 就能 Down 下所有所需资源，与此同时做好 cache-controll 中的缓存策略处理，保证下次连接返回 200(from cache)，弥补下首次加载的速度。</p>\n</blockquote>\n<p>我想，这样比问“HTTP 协议”，“三次握手”、“网络协议”、“W3C 标准协议”、“性能优化”、“安全性”等问题更具有挑战吧？</p>\n<p>另外，我知道 TCP 有三次握手，但是每次握手改变什么标记字段对我前端又有啥帮助呢？</p>\n<p>(完)</p>","timeToRead":1,"wordCount":{"paragraphs":8,"sentences":8,"words":74},"fields":{"slug":"/zhuan-zai-qian-duan-wo/","relativePath":"2016/2016-10-20---zhuan-zai-qian-duan-wo/index.md"},"excerpt":"…","frontmatter":{"title":"(转载)前端，我为什么不要你","date":"20 Oct 2016","tags":["随笔"],"cover":"","comments":true,"author":"烈风裘"}},"prevPost":{"html":"<p>为了加快网页的访问速度，对请求资源进行缓存是一个常用的策略。当客户端发送资源请求后，如果资源未过期，则服务器返回 304 代表资源未修改使用浏览器本地缓存，但是这个过程还是会发生 TCP 连接，如果不发送请求就能知道本地的缓存副本就是最新的按就好了。</p>\n<p>其中的一个解决方案就是使用 HTML5 的最新特性离线存储(manifest)来解决。通过离线存储，我们可以通过把需要离线存储在本地的文件列在一个 manifest 配置文件中，这样即使在离线的情况下，用户也可以正常使用 App。同时，由之前返回的 304(not modified)全部变成 200(from cache)，也即是说不用再请求服务器资源了。</p>\n<blockquote>\n<p>PS：应该是在单页面 SPA 应用中多使用此技术，除了 IE9 及其以下版本不兼容，其余浏览器都兼容。</p>\n</blockquote>\n<h3 id=\"怎么使用\" style=\"position:relative;\"><a href=\"#%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8\" aria-label=\"怎么使用 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>怎么使用</h3>\n<p>在 html 中加入 manifest 的属性就可以了。</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">DOCTYPE</span> <span class=\"token name\">HTML</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">manifest</span> <span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span> <span class=\"token punctuation\">\"</span>cache.manifest<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n...\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>之后编写<code class=\"language-text\">cache.manifest</code>文件(此文件一般是通过自动化工具来做生成，手动维护很痛苦)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CACHE MANIFEST\n\nCACHE:\nhttp://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css\nhttp://cdn.bootcss.com/font-awesome/4.6.3/fonts/fontawesome-webfont.woff2?v=4.6.3\nhttp://xiangsongtao.com/static/css/app.40ca310ea17e37e2c7d1be290f097782.css\nhttp://xiangsongtao.com/static/js/0.cc35128bd8494c03daa0.js\nhttp://xiangsongtao.com/static/js/1.9f1833ed33a94fe44f61.js\nhttp://xiangsongtao.com/static/js/2.6fd53cc0491419739c75.js\nhttp://xiangsongtao.com/static/js/3.7d2782ebd4a9ccfc73c3.js\nhttp://xiangsongtao.com/static/js/4.3ffed0ad00e3cbf19311.js\nhttp://xiangsongtao.com/static/js/5.0864b0b318aed8c5e5c3.js\nhttp://xiangsongtao.com/static/js/6.8cf1f468ef4e49b1fb0d.js\nhttp://xiangsongtao.com/static/js/7.da83992afd496d4889e3.js\nhttp://xiangsongtao.com/static/js/8.a75be465a534de6bc590.js\nhttp://xiangsongtao.com/static/js/app.88635de0da664917c9bc.js\nhttp://xiangsongtao.com/static/js/manifest.c3d7bc712610ce511e9b.js\nhttp://xiangsongtao.com/static/js/vendor.dd1992f099a201029616.js\n\nNETWORK:\n*\n\nSETTINGS:\nprefer-online\n\n# hash: f98a3b3dac77c6644dc0795a6fb7e44ca03f41b33ff6d738d3da57b783abf5f1\n\nFALLBACK:\n/ /offline.html</code></pre></div>\n<p>SETTINGS 可以设置成两种模式，默认是 fast。但是在我的测试中没感觉到这两种模式有什么区别，这个就暂时不说了。</p>\n<p>这些就是 manifest 缓存最基本的东西，还有一个很大的问题就是火狐的警告。当使用 manifest 时，火狐下会出现警告。</p>\n<p>生成上述 manifest 文件的 gulp 配置如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&#39;use strict&#39;;\nvar  gulp  = require(&#39;gulp&#39;);\nvar  gulpLoadPlugins  = require(&#39;gulp-load-plugins&#39;);\nvar $ = gulpLoadPlugins();\n\ngulp.task(&#39;manifest&#39;, function(){\n  gulp.src([&#39;dist/static/**/*.{js,css}&#39;], { base: &#39;./dist&#39; })\n    .pipe($.manifest({\n      hash: true,\n      preferOnline: true,\n      prefix:&#39;http://xiangsongtao.com/&#39;,\n      network: [&#39;*&#39;],\n      cache:[\n        &#39;http://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css&#39;,\n        &#39;http://cdn.bootcss.com/font-awesome/4.6.3/fonts/fontawesome-webfont.woff2?v=4.6.3&#39;,\n      ],\n      filename: &#39;app.manifest&#39;,\n      exclude: [&#39;app.manifest&#39;]\n    }))\n    .pipe(gulp.dest(&#39;dist&#39;));\n});</code></pre></div>\n<h3 id=\"manifest-解析过程\" style=\"position:relative;\"><a href=\"#manifest-%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B\" aria-label=\"manifest 解析过程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>manifest 解析过程</h3>\n<p>在线情况第一次访问，则查找 html 中的 manifest 文件，如果有则下载里面需要缓存的资源。第二次访问的时候，浏览器使用本地缓存副本渲染网页，之后判断 manifest 中的文件是否更新，如果未更新则不操作；如果已更新，则下载最新副本缓存（也就是说，更新 manifest 后并不会立即生效，需要再刷新下）,这个问题我们可以用代码进行手动缓存的刷新解决，调用<code class=\"language-text\">window.applicationCache.update()</code>进行缓存刷新，<code class=\"language-text\">window.applicationCache.swapCache()</code>进行重新请求更新的资源进行渲染。</p>\n<h3 id=\"manifest-过程对应的事件\" style=\"position:relative;\"><a href=\"#manifest-%E8%BF%87%E7%A8%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BA%8B%E4%BB%B6\" aria-label=\"manifest 过程对应的事件 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>manifest 过程对应的事件</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> window.applicationCache.onnoupdate = function(){\n            console.debug(&#39;onnoupdate!!!!&#39;)\n}</code></pre></div>\n<ol>\n<li>oncached:当离线资源存储完成之后触发这个事件，这个是文档的说法，我在 Chrome 上面测试的时候并没有触发这个事件（onobsolete 也是）。</li>\n<li>onchecking:当浏览器对离线存储资源进行更新检查的时候会触发这个事件</li>\n<li>ondownloading:当浏览器开始下载离线资源的时候会触发这个事件</li>\n<li>onprogress:当浏览器在下载每一个资源的时候会触发这个事件，每下载一个资源就会触发一次。</li>\n<li>onupdateready:当浏览器对离线资源更新完成之后会触发这个事件</li>\n<li>on 中 noupdate:当浏览器检查更新之后发现没有资源更新的时候触发这个事件</li>\n<li>onerror: 当 manifest 中缓存的资源下载错误是触发</li>\n</ol>\n<h3 id=\"manifest-使用场景\" style=\"position:relative;\"><a href=\"#manifest-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\" aria-label=\"manifest 使用场景 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>manifest 使用场景</h3>\n<p>manifest 的名字叫 Application Cache 就已经很好的定性了，它是用来构造离线应用程序的。比方说你写了个秒表，它离线也能用，这是 manifest 的应用场景。它会讲当前访问的 HTML 也缓存起来，故实时的 web 还是别用了。</p>\n<p>如果要缓存资源，设置<code class=\"language-text\">Cache Control</code>和<code class=\"language-text\">Expires</code>来做吧，这个见我的另外一篇文章。</p>\n<h3 id=\"参考资源\" style=\"position:relative;\"><a href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90\" aria-label=\"参考资源 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参考资源</h3>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/gulp-manifest\" target=\"_target\" rel=\"nofollow\">Gulp-manifest</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000000732617\" target=\"_target\" rel=\"nofollow\">原文参考 1</a></li>\n<li><a href=\"http://bin-playground.top\" target=\"_target\" rel=\"nofollow\">原文参考 2</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache\" target=\"_target\" rel=\"nofollow\">Using<em>the</em>application_cache</a></li>\n<li><a href=\"http://diveintohtml5.info/offline.html\" target=\"_target\" rel=\"nofollow\">LET’S TAKE THIS OFFLINE</a></li>\n</ul>","timeToRead":5,"wordCount":{"paragraphs":28,"sentences":28,"words":152},"fields":{"slug":"/Manifest-de-di-shi-yong/","relativePath":"2016/2016-10-20---Manifest-de-di-shi-yong/index.md"},"excerpt":"为了加快网页的访问速度，对请求资源进行缓存是一个常用的策略。当客户端发送资源请求后，如果资源未过期，则服务器返回 304 代表资源未修改使用浏览器本地缓存，但是这个过程还是会发生 TCP…","frontmatter":{"title":"Manifest的使用","date":"20 Oct 2016","tags":["缓存"],"cover":"","comments":true,"author":"烈风裘"}}},"pageContext":{"curr":"/deng-lu-liu-cheng-jia-mi-de-di-si-sai-kao/","prev":"/Manifest-de-di-shi-yong/","next":"/zhuan-zai-qian-duan-wo/"}},"staticQueryHashes":["3240721340","63159454"]}