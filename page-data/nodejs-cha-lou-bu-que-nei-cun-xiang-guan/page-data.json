{"componentChunkName":"component---src-templates-blog-post-js","path":"/nodejs-cha-lou-bu-que-nei-cun-xiang-guan/","result":{"data":{"site":{"siteMetadata":{"title":"Attila","cover":"/background/1.jpg","description":"Thoughts, stories and ideas.","keywords":["烈风裘的博客","X-Blog","Attila","Gatsby","前端成长记录"],"tagCover":"/background/5.jpg","archiveCover":"/background/escape-flight.png","siteUrl":"https://xiangst0816.github.io/blog","logo":"","navigation":true,"subscribe":true}},"allAuthorJson":{"totalCount":2,"edges":[{"node":{"id":"烈风裘","bio":"一往无前, 直到云开雾散!","avatar":"/avatar/avatar.jpeg","cover":"/background/photo-1503197979108-c824168d51a8.jpeg","github":"https://github.com/xiangst0816","twitter":"","zhihu":"","weibo":"","facebook":"","website":"https://xiangst0816.github.io/blog/","location":"HangZhou, China"}},{"node":{"id":"WALL-E","bio":"还有要清理的吗?","avatar":"/avatar/cleaner.jpg","cover":"","github":null,"twitter":null,"zhihu":null,"weibo":null,"facebook":null,"website":null,"location":"Earth"}}]},"master":{"id":"烈风裘","bio":"一往无前, 直到云开雾散!","avatar":"/avatar/avatar.jpeg","cover":"/background/photo-1503197979108-c824168d51a8.jpeg","github":"https://github.com/xiangst0816","twitter":"","zhihu":"","weibo":"","facebook":"","website":"https://xiangst0816.github.io/blog/","location":"HangZhou, China"},"currentPost":{"html":"<h3 id=\"1-v8为什么会有内存限制，原因是什么，如何解除？\" style=\"position:relative;\"><a href=\"#1-v8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%EF%BC%8C%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E9%99%A4%EF%BC%9F\" aria-label=\"1 v8为什么会有内存限制，原因是什么，如何解除？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. V8为什么会有内存限制，原因是什么，如何解除？</h3>\n<p><strong>V8限制堆的大小，分为两个层次的原因：</strong></p>\n<ol>\n<li><strong>表层原因</strong>：是因为V8最终为浏览器设计，大内存使用场景无法遇到；</li>\n<li><strong>深层原因</strong>：是因为V8的垃圾回收机制限制。以1.5G的垃圾回收堆内存为例，一次小回收需要50ms以上，做一次非增量式的垃圾回收甚至要1s以上。垃圾回收过程JS线程暂停，应用性能和响应能力直线下降。限制是一个好选择（JAVA也有类似的设计）。</li>\n</ol>\n<p><strong>解除方式：</strong></p>\n<p>可以在Node启动的时候增加额外的启动参数调整old和new两个内存限制的大小：</p>\n<div class=\"gatsby-highlight\" data-language=\" shell\"><pre class=\"language- shell\"><code class=\"language- shell\">node --max-old-space-size=1700 test.js // 单位为MB\nnode --max-new-space-size=1024 test.js // 单位为KB</code></pre></div>\n<h3 id=\"2-简述v8的垃圾回收机制，为什么会有内存分代？\" style=\"position:relative;\"><a href=\"#2-%E7%AE%80%E8%BF%B0v8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%86%85%E5%AD%98%E5%88%86%E4%BB%A3%EF%BC%9F\" aria-label=\"2 简述v8的垃圾回收机制，为什么会有内存分代？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 简述V8的垃圾回收机制，为什么会有内存分代？</h3>\n<p>V8的垃圾回收策略主要基于<strong>分代式垃圾回收机制</strong>。使用分代式的原因：</p>\n<ol>\n<li><strong>没有一种垃圾回收算法</strong>能够胜任所有场景；</li>\n<li>按照<strong>对象的存活时间</strong>将内存的垃圾回收进行不同的分代，不同分代实施不同的策略更高效；</li>\n</ol>\n<p><strong>分代方式及大小：</strong></p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 840px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.285714285714285%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAAA60lEQVQoz1WRyaqEQAxF+/8/zYUgqCtBXKgb59lySHPyXsQuCKm6SW5uUh95nXVdpW1baZpG9n2X67p+rOs6qeta/XmeD879vm/l+PR9L2VZCj6OY0mSRMIwVL9tmzjnxO1OPW+MZor/27IschzHHyFqsizTrp7nSRRF4vu+kpNEZ1SYAnub8abBQ8iY1mUcRx13GAaZpkksRgHK5nl+FJoRJ4+xlRBFQRBIURQKQGg7sT1xKK6q6ikkbvazwzzPdWR2CIhHhZFZARgxGw8Mde88JUzTVHfG7wIyNneS378PDiHrYHSMPGJvxV8uUx4BlDEmrgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"分代方式及大小\"\n        title=\"分代方式及大小\"\n        src=\"/blog/static/34066063057e6a450fcfef6671b7ae55/f88f5/image-20200817110425925.png\"\n        srcset=\"/blog/static/34066063057e6a450fcfef6671b7ae55/e1650/image-20200817110425925.png 210w,\n/blog/static/34066063057e6a450fcfef6671b7ae55/8cae7/image-20200817110425925.png 420w,\n/blog/static/34066063057e6a450fcfef6671b7ae55/f88f5/image-20200817110425925.png 840w,\n/blog/static/34066063057e6a450fcfef6671b7ae55/57a2b/image-20200817110425925.png 1260w,\n/blog/static/34066063057e6a450fcfef6671b7ae55/b5d14/image-20200817110425925.png 1680w,\n/blog/static/34066063057e6a450fcfef6671b7ae55/56625/image-20200817110425925.png 1716w\"\n        sizes=\"(max-width: 840px) 100vw, 840px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">分代方式及大小</figcaption>\n  </figure></p>\n<p>V8内存分代分为两部分：<strong>新生代内存空间</strong>和<strong>老生代内存空间</strong>；内存对应的默认最大大小如上图；不同分代执行的算法不同。</p>\n<p><strong>Scavenge算法（新旧Space倒换，引用计数方式）</strong>：通过复制的方式，从<strong>From</strong>到<strong>To</strong>之间复制存活的对象。因为在此分代中（生命周期短的场景），存活的对象只占少部分，因此性能好。对于多次复制依然存活的对象，会转移到老生代中（晋升），转移算法如下。</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 840px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAAA4ElEQVQoz4VSSQ6DQAzj/99CXDlxZL9wQEjsO7hy1IymQNtI0STE8jgeHLzjPE85t21DXdcIwxBxHGMYBuz7/oH5FY4CFTzPM8ZxRBRFyPNc+nVdYeOeUueO3dgKSLosC+wNfinU2U0h1UzTJKtTHWtdWbGcHcchydlNoSbJ6J3ruvB9X07P85BlmZDTW2ZVVQiCAEmSmMtvhAze1vc90jSVByFRURTyTdWQmFaUZYm2bUUEZ4bw6oEGgfaqT37ZtfHw+lLqDVfrus70V6+v9VeFVNY0jXhIn/jatkf/fpsX11jASuRCRhYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"新生代转移算法\"\n        title=\"新生代转移算法\"\n        src=\"/blog/static/dd05683c5b7886c35659a4abaa456f20/f88f5/image-20200817110448724.png\"\n        srcset=\"/blog/static/dd05683c5b7886c35659a4abaa456f20/e1650/image-20200817110448724.png 210w,\n/blog/static/dd05683c5b7886c35659a4abaa456f20/8cae7/image-20200817110448724.png 420w,\n/blog/static/dd05683c5b7886c35659a4abaa456f20/f88f5/image-20200817110448724.png 840w,\n/blog/static/dd05683c5b7886c35659a4abaa456f20/57a2b/image-20200817110448724.png 1260w,\n/blog/static/dd05683c5b7886c35659a4abaa456f20/6a7f9/image-20200817110448724.png 1586w\"\n        sizes=\"(max-width: 840px) 100vw, 840px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">新生代转移算法</figcaption>\n  </figure></p>\n<p><strong>Mark-Sweep算法（标记清除）</strong>：只标记活着的对象，对于没标记的对象进行清除；因为死对象在老生代中只占少部分，所以效率高。老生代内存空间主要以此算法为主（Mark-Sweep），但是会存在文件碎片，当空间不足以对分配新晋升的对象是，才使用下面的Mark-Compact算法；</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 840px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.190476190476193%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAAA80lEQVQY032QPYqEQBCFG7yBwYCBkV5hIk9g6CXMRCY1NDbSzMQTKJ7AAyiCkamMIGKiBib+vqGaHTfaLXhUvS76o6oYfuK6LvwX4zji/X7/2T/Pk2dGINJxHPA8D2VZom1buK6LaZrgOA5M00QQBJjnGa/XC0VRwPd92LYNy7JQ1/UNvYEkSZIQRRHyPIcgCBzMGONSFAVd1/E6DEOoqnr3kiThwH3ff4FkdF1HmqaoqgqapmEYBjyfT4iiCMMw0Pc9ZFlGHMfc0wCPxwNZlnEgbcm+t6O8bRsHL8vCp2uahq9Nb9SjldZ15R/JU0363o8YH9ebRCVj5BJvAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Mark-Sweep算法\"\n        title=\"Mark-Sweep算法\"\n        src=\"/blog/static/8d0c601cc10b231fcc1344bdc47e407d/f88f5/image-20200817110509950.png\"\n        srcset=\"/blog/static/8d0c601cc10b231fcc1344bdc47e407d/e1650/image-20200817110509950.png 210w,\n/blog/static/8d0c601cc10b231fcc1344bdc47e407d/8cae7/image-20200817110509950.png 420w,\n/blog/static/8d0c601cc10b231fcc1344bdc47e407d/f88f5/image-20200817110509950.png 840w,\n/blog/static/8d0c601cc10b231fcc1344bdc47e407d/57a2b/image-20200817110509950.png 1260w,\n/blog/static/8d0c601cc10b231fcc1344bdc47e407d/ed226/image-20200817110509950.png 1542w\"\n        sizes=\"(max-width: 840px) 100vw, 840px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">Mark-Sweep算法</figcaption>\n  </figure></p>\n<p><strong>Mark-Compact算法（标记整理）</strong>：标记内存对象，整理的过程中将活着的和死去的对象分向两头，移动完之后直接清理掉边界之外的内存。</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 840px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.61904761904762%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAAAvklEQVQY05WPSwqDQBBER6/q0pO483MBEUHHS8QLuFZvILhRBBF/FapBoyEJpKDomoZ5dKl93/FJ7/u+79E0DX5p2zYohnVdsSzL6XmeBdh1HeI4RhiGSNNUcpIkyHQGrfXpKIpQFIVABUgI6YRw8k3VdQ3TNKGUgmEYMr/Ztu078FrxyFVV/YRcbVnWHUgPw4BxHMWs3bYtgiCA53nwfR+u64qZuTv2juMgf+QvIC866hJalqVcN00T/hH/PwHSsII5LGUT5AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Mark-Compact算法\"\n        title=\"Mark-Compact算法\"\n        src=\"/blog/static/b1a13e38721de90579247d2b40244d54/f88f5/image-20200817110522895.png\"\n        srcset=\"/blog/static/b1a13e38721de90579247d2b40244d54/e1650/image-20200817110522895.png 210w,\n/blog/static/b1a13e38721de90579247d2b40244d54/8cae7/image-20200817110522895.png 420w,\n/blog/static/b1a13e38721de90579247d2b40244d54/f88f5/image-20200817110522895.png 840w,\n/blog/static/b1a13e38721de90579247d2b40244d54/57a2b/image-20200817110522895.png 1260w,\n/blog/static/b1a13e38721de90579247d2b40244d54/a66c0/image-20200817110522895.png 1514w\"\n        sizes=\"(max-width: 840px) 100vw, 840px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">Mark-Compact算法</figcaption>\n  </figure></p>\n<p><strong>算法改进部分（顾名思义）</strong></p>\n<p>Mark-Sweep部分 -> Incremental Marking（增量标记）、Lazy-Sweeping（延迟清除）</p>\n<p>Mark-Compact部分 -> Incremental Compaction（增量整理）</p>\n<h3 id=\"3-导致内存泄漏的常见类型有哪些，如何规避？\" style=\"position:relative;\"><a href=\"#3-%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F\" aria-label=\"3 导致内存泄漏的常见类型有哪些，如何规避？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 导致内存泄漏的常见类型有哪些，如何规避？</h3>\n<blockquote>\n<p>闭包：实现 <strong>外部作用域</strong> 访问 <strong>内部作用域</strong> 中变量的方法（一般情况下外部作用域无法方位内部的）</p>\n</blockquote>\n<p><strong>常见类型及规避方案</strong></p>\n<ul>\n<li><u>缓存</u>：1. 增加缓存策略；2. 使用三方缓存方案</li>\n<li><u>队列消费不及时</u>：1. 监控队列长度；2. 任意异步调用都应该包含超时机制</li>\n<li><u>作用域未释放</u>：闭包和全局变量两种；通过赋值的方式（undefined or null）解除引用更好。通过delete删除对象属性有可能干扰V8的优化。</li>\n</ul>\n<p><mark>以上场景类型涉及到的对象都在<strong>老生代内存空间</strong>中！</mark></p>\n<h3 id=\"4-如何理解堆内内存及堆外内存？node应用的内存构成是？\" style=\"position:relative;\"><a href=\"#4-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%A0%86%E5%86%85%E5%86%85%E5%AD%98%E5%8F%8A%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%EF%BC%9Fnode%E5%BA%94%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%9E%84%E6%88%90%E6%98%AF%EF%BC%9F\" aria-label=\"4 如何理解堆内内存及堆外内存？node应用的内存构成是？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 如何理解堆内内存及堆外内存？Node应用的内存构成是？</h3>\n<p>Node的内存构成主要由 <strong>通过V8进行分配的部分</strong> 和 <strong>Node自定分配的部分</strong>。</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 840px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.476190476190474%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAAAvUlEQVQoz4WSiw6EIAwE+f9P1agB3/jo3TTppYcamxBJC9PtYpBvnOepy/bEcRzSdZ3UdS0pJXk6V0bwRfvmnGUcRxmGQfq+1/26rq+wH9AfmudZFQEAbLFtm4I99A78p3Dfd4kx6uVlWRQKhBzjT9OkDT2wVB3KURmRhXdAUds0jVRVpVDz04dXevEQNYDZowi1KLWR27ZVb8lR5/EuCn2CiyjksO9sYJpRMyA23QLLX4YLjIxn5ufT6/r8Bxh+dnlrbm2hAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"堆内外示例\"\n        title=\"堆内外示例\"\n        src=\"/blog/static/a5b0ae0162d0c8471e091b50665f9277/f88f5/image-20200817110538576.png\"\n        srcset=\"/blog/static/a5b0ae0162d0c8471e091b50665f9277/e1650/image-20200817110538576.png 210w,\n/blog/static/a5b0ae0162d0c8471e091b50665f9277/8cae7/image-20200817110538576.png 420w,\n/blog/static/a5b0ae0162d0c8471e091b50665f9277/f88f5/image-20200817110538576.png 840w,\n/blog/static/a5b0ae0162d0c8471e091b50665f9277/57a2b/image-20200817110538576.png 1260w,\n/blog/static/a5b0ae0162d0c8471e091b50665f9277/3bb79/image-20200817110538576.png 1484w\"\n        sizes=\"(max-width: 840px) 100vw, 840px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">堆内外示例</figcaption>\n  </figure></p>\n<p>所以堆内内存主要指的是V8管理的内存，堆外是Node自行管理的部分，比如Buffer的使用。</p>\n<h3 id=\"5-大内存应用如何处理？\" style=\"position:relative;\"><a href=\"#5-%E5%A4%A7%E5%86%85%E5%AD%98%E5%BA%94%E7%94%A8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F\" aria-label=\"5 大内存应用如何处理？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 大内存应用如何处理？</h3>\n<p>如问题4，使用堆外内存方式处理，比如使用<strong>Stream</strong>方式。使用 <strong>流</strong> 的方式处理，下面代码不会受到V8内存限制的影响，有效的提高程序的健壮性。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> reader <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">createReadStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">'in.txt'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> writer <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">createWriteStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">'out.txt'</span><span class=\"token punctuation\">)</span>\nreader<span class=\"token punctuation\">.</span><span class=\"token function\">pip</span><span class=\"token punctuation\">(</span>writer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","timeToRead":5,"wordCount":{"paragraphs":35,"sentences":35,"words":129},"fields":{"slug":"/nodejs-cha-lou-bu-que-nei-cun-xiang-guan/","relativePath":"2020/2020-08-17---nodejs-cha-lou-bu-que-nei-cun-xiang-guan/index.md"},"excerpt":"1. V8为什么会有内存限制，原因是什么，如何解除？ V8限制堆的大小，分为两个层次的原因： 表层原因：是因为V8最终为浏览器设计，大内存使用场景无法遇到； 深层原因：是因为V8的垃圾回收机制限制。以1.5G…","frontmatter":{"title":"Nodejs查漏补缺-内存相关","date":"17 Aug 2020","tags":["Node"],"cover":"","comments":true,"author":"烈风裘"}},"nextPost":{"html":"<h3 id=\"1-新建buffer会占用v8分配的内存吗？\" style=\"position:relative;\"><a href=\"#1-%E6%96%B0%E5%BB%BAbuffer%E4%BC%9A%E5%8D%A0%E7%94%A8v8%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98%E5%90%97%EF%BC%9F\" aria-label=\"1 新建buffer会占用v8分配的内存吗？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 新建Buffer会占用V8分配的内存吗？</h3>\n<p>不会，Buffer属于堆外内存，不是V8分配的</p>\n<h3 id=\"2-buffer的内存分配机制\" style=\"position:relative;\"><a href=\"#2-buffer%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6\" aria-label=\"2 buffer的内存分配机制 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Buffer的内存分配机制</h3>\n<p>Buffer对象类似数组，它的元素为16进制的两位数，即0到255的数值。<strong>其内存分配是在Node的C++层面实现的内存的申请，但是在JavaScript层面分配内存</strong>。Node采用了<strong>slab分配机制</strong>，以<strong>8KB</strong>为界限区分Buffer是大对象还是小对象。</p>\n<p><strong>小对象（&#x3C;8KB）：</strong></p>\n<p>采用slab的机制进行预先申请和事后分配的策略。例如第一次分配一个1024字节的Buffer，Buffer.alloc(1024)，那么这次分配就会用到一个slab，接着如果继续Buffer.alloc(1024)，那么上一次用的slab的空间还没有用完，因为总共是8kb，1024+1024 = 2048个字节，没有8kb，所以就继续用这个slab给Buffer分配空间。如果下次超过剩余空间，则重新申请一个新的slab存数据。</p>\n<p><strong>大对象（>8KB）：</strong></p>\n<p>直接分配一个SlowBuffer对象作为slab单元，这个slab单元会被这个大Buffer对象独占。</p>\n<h3 id=\"3-buffer与string的关系\" style=\"position:relative;\"><a href=\"#3-buffer%E4%B8%8Estring%E7%9A%84%E5%85%B3%E7%B3%BB\" aria-label=\"3 buffer与string的关系 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Buffer与String的关系</h3>\n<p>Buffer是二进制数据，字符串与Buffer之间存在编码关系，通过setEncoding方式进行转码。但是Node的Buffer支持的编码类型有限，需要借助iconv等工具进行拓展。</p>","timeToRead":1,"wordCount":{"paragraphs":10,"sentences":10,"words":44},"fields":{"slug":"/nodejs-cha-lou-bu-que-buffer-xiang-guan/","relativePath":"2020/2020-08-16---nodejs-cha-lou-bu-que-buffer-xiang-guan/index.md"},"excerpt":"1. 新建Buffer会占用V8分配的内存吗？ 不会，Buffer属于堆外内存，不是V8分配的 2. Buffer的内存分配机制 Buffer对象类似数组，它的元素为16进制的两位数，即0到25…","frontmatter":{"title":"Nodejs查漏补缺-Buffer相关","date":"16 Aug 2020","tags":["Node"],"cover":"","comments":true,"author":"烈风裘"}},"prevPost":null},"pageContext":{"curr":"/nodejs-cha-lou-bu-que-nei-cun-xiang-guan/","prev":"","next":"/nodejs-cha-lou-bu-que-buffer-xiang-guan/"}},"staticQueryHashes":["3240721340","63159454"]}