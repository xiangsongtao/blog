{"componentChunkName":"component---src-templates-tag-page-js","path":"/tag/java-script/","result":{"data":{"site":{"siteMetadata":{"title":"Attila","cover":"/background/1.jpg","author":"@烈风裘","description":"Thoughts, stories and ideas.","keywords":["烈风裘的博客","X-Blog","Attila","Gatsby","前端成长记录"],"tagCover":"/background/5.jpg","archiveCover":"/background/escape-flight.png","siteUrl":"https://xiangst0816.github.io/blog","logo":"","navigation":true,"subscribe":true}},"master":{"id":"烈风裘"},"allAuthorJson":{"totalCount":2,"edges":[{"node":{"id":"烈风裘","avatar":"/avatar/avatar.png"}},{"node":{"id":"WALL-E","avatar":"/avatar/cleaner.jpg"}}]},"allMarkdownRemark":{"totalCount":13},"currentMarkdownRemark":{"edges":[{"node":{"excerpt":"这里所指都是在浏览器环境中，而不是 Nodejs 环境。 JS 异步机制 关于 JS 简要的运行机制及事件队列等知识强烈希望能翻墙看下这个视频：地址。 这里有个很重要的图需要深刻理解：  Chrome 中的 V8 只处理 JS 的解析及执行（可能有歧义） JS 运行在单线程上，通过 event loop 完成异步调度 DOM、XMLHTTPREquest、setTimeout、setInterval 等是异步的 WebAPIs 异步代码会被推入 callback queue（Tasks…","fields":{"slug":"/js-shi-jian-ji-zhi/"},"frontmatter":{"title":"JS事件机制及Tasks和microtasks的区别","tags":["JavaScript"],"star":false,"date":"24 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"写代码的时候经常用到，但是被问起却哑口无言，或者只能说到表面，这里再详细总结写，查漏补缺。 介绍 JavaScript…","fields":{"slug":"/bi-bao/"},"frontmatter":{"title":"闭包","tags":["JavaScript"],"star":false,"date":"01 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"就是下面这样的的代码： 关于 IIFE 书写方式 第一种情况： 解释：JavaScript 在解析代码时，当遇到关键字时，会默认把它当做一个函数声明，而不是函数表达式，如果没有把它显式的写成函数表达式，就报错，因为函数声明需要一个函数名。上面的报错是因为没有函数名(第一个左括号)。 第二种情况： 解释：在表达式后面加括号表示执行；此外，在函数声明一个语句，在语句后面加括号可等价为： 相当于声明了函数 foo…","fields":{"slug":"/IIFE-li-ji-zhi-hang-xing-han-shu-shuo/"},"frontmatter":{"title":"IIFE立即执行函数","tags":["JavaScript"],"star":false,"date":"01 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"这里说的变量提升指的是使用var声明的变量 变量提升也可以说是“变量声明前置”，就是把函数里面用到的变量声明提升到前面，赋值步骤在书写的位置进行。 是否使用 var 定义变量的区别 使用 var 定义的变量是函数级变量，只在函数内能访问到。 不使用 var 定义的变量是全局变量，等同于 块级作用域和函数级作用域 使用传统的定义的变量执行的是函数级作用域。 描述一下就是：在函数中使用定义的变量都会将变量声明放在函数的第一行，变量赋值在书写的位置赋值。 使用 let…","fields":{"slug":"/bian-liang-ti-di-sheng/"},"frontmatter":{"title":"变量提升","tags":["JavaScript"],"star":false,"date":"01 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"this 是什么 在函数运行时，基于调用位置的条件自动生成的内部对象，可以理解为动态绑定对象到 this 上。 需要强调的是： 只针对函数，在函数内部使用 this 由调用位置的上下文自动的决定，而不是函数声明的位置（代码书写的位置） 必须是运行时才确定，而不是编写时 this 绑定之后可理解为自动生成的内部对象 示例： this 的四个绑定规则及优先级 下面四个为 this 的绑定优先级规则，第一个优先级最高。判断执行流程需要做的就是找到函数的调用位置并判断使用哪条规则。…","fields":{"slug":"/guan-yu-this/"},"frontmatter":{"title":"关于this","tags":["JavaScript"],"star":false,"date":"30 Dec 2017","author":"烈风裘"}}},{"node":{"excerpt":"文章总结的时间是 2017/11/20 本文是为了梳理 Babel 配置及使用而整理，因为看过使用 Babel 配置项目和文章，存在项目插件使用混乱、文章各种照搬、插件使用听风是雨、插件升级文章内容不再适用的问题。这里就目前最新使用的配置组合进行整理，涉及的插件包括以下三个： @babel/preset-env(^7.0.0-beta.32) @babel/preset-stage-x(7.0.0-beta.32), x-0,1,2,3 @babel/polyfill(^7.0.0-beta…","fields":{"slug":"/guan-yu-Babel-zui-xin-shi-yong-fang-shi/"},"frontmatter":{"title":"关于Babel最新使用方式","tags":["Babel","JavaScript"],"star":false,"date":"19 Nov 2017","author":"烈风裘"}}},{"node":{"excerpt":"什么是 arguments arguments 是一个类数组的对象，代表传给一个 function 的参数列表。 arguments 操作 arguments length arguments 是个类数组对象，其包含一个 length 属性，可以用 arguments.length 来获得传入函数的参数个数。 arguments 转数组 arguments 传递出去 将函数的 arguments 对象泄露出去了，最终的结果就是 V…","fields":{"slug":"/JavaScriptarguments-dui-xiang-quan/"},"frontmatter":{"title":"JavaScript arguments 对象全面介绍","tags":["JavaScript"],"star":false,"date":"22 Oct 2016","author":"烈风裘"}}},{"node":{"excerpt":"记得很早之前就对正则进行了简单的学习，我自己在下面也总结了很多次，但是一到用的时候就懵逼了。看来还是实践较少的结果。今天特此花时间在总结下，并且附上常用的正则示例。 思维导图： 正则 常用示例： 去除首位空格（单独去除左右空格类似）： “v-err-src”转化为驼峰名字”vErrSrc”： xxx-xxxx-xxxxx, 前三位数字开头，中间四位字母开头数字结尾，后 5 位随意： 邮箱验证： 中文范围： 以上就差不多这些了！","fields":{"slug":"/zheng-ze-jian-dan-shan-chan-zong-jie/"},"frontmatter":{"title":"正则简单总结","tags":["正则","JavaScript"],"star":false,"date":"20 Oct 2016","author":"烈风裘"}}},{"node":{"excerpt":"先说下基础类型和引用类型 在写代码的时候翻看源码无意中看到了对象的深浅复制的代码，估计以后也会用的上，虽然徒手从零开始写有些困难，但是使用的时候能快速拿出来也是好的。下面是对深浅复制的总结笔记！ 分类 在 JS 中有一些基本类型像是、、，而对象就是像这样的东西，对象跟基本类型最大的不同就在于他们的传值方式。 基本类型是传 value，像是这样： 在修改时并不会改到 但对象就不同，对象传的是 reference： 复制一份叫做，然后把改成 10…","fields":{"slug":"/JS-shen-qian-jian-kao-bei-xiang-guan/"},"frontmatter":{"title":"JS深浅拷贝相关","tags":["JavaScript"],"star":false,"date":"20 Oct 2016","author":"烈风裘"}}},{"node":{"excerpt":"常用的类型判断 typeof 在进行类型判断时，第一反应是使用 typeof 来做，写法： 但是这个方法可返回的类型只有以下几种（注意都是小写）： (对象,数组,日期和 null)、 、、、、 需要特别注意的是，使用 typeof 判断未定义的变量不会抛出异常，但是其余方法都会！ instanceof 判断 instanceof 用于判断一个变量是否某个对象的实例，是一个三目运算式 这里的 instanceof 测试的 object 是指 js 语法中的 object，不是指 dom…","fields":{"slug":"/JS-lei-xing-pan-duan/"},"frontmatter":{"title":"JS类型判断","tags":["JavaScript"],"star":false,"date":"20 Oct 2016","author":"烈风裘"}}}]}},"pageContext":{"tag":"JavaScript"}},"staticQueryHashes":["3240721340","63159454"]}