{"componentChunkName":"component---src-templates-tag-page-js","path":"/tag/node/","result":{"data":{"site":{"siteMetadata":{"title":"Attila","cover":"/background/1.jpg","author":"@烈风裘","description":"Thoughts, stories and ideas.","keywords":["烈风裘的博客","X-Blog","Attila","Gatsby","前端成长记录"],"tagCover":"/background/5.jpg","archiveCover":"/background/escape-flight.png","siteUrl":"https://xiangst0816.github.io/blog","logo":"","navigation":true,"subscribe":true}},"master":{"id":"烈风裘"},"allAuthorJson":{"totalCount":2,"edges":[{"node":{"id":"烈风裘","avatar":"/avatar/me.jpeg"}},{"node":{"id":"WALL-E","avatar":"/avatar/cleaner.jpg"}}]},"allMarkdownRemark":{"totalCount":4},"currentMarkdownRemark":{"edges":[{"node":{"excerpt":"1. V8为什么会有内存限制，原因是什么，如何解除？ V8限制堆的大小，分为两个层次的原因： 表层原因：是因为V8最终为浏览器设计，大内存使用场景无法遇到； 深层原因：是因为V8的垃圾回收机制限制。以1.5G的垃圾回收堆内存为例，一次小回收需要50ms以上，做一次非增量式的垃圾回收甚至要1s以上。垃圾回收过程JS线程暂停，应用性能和响应能力直线下降。限制是一个好选择（JAVA也有类似的设计）。 解除方式： 可以在Node启动的时候增加额外的启动参数调整old和new两个内存限制的大小：…","fields":{"slug":"/nodejs-cha-lou-bu-que-nei-cun-xiang-guan/"},"frontmatter":{"title":"Nodejs查漏补缺-内存相关","tags":["Node"],"star":false,"date":"17 Aug 2020","author":"烈风裘"}}},{"node":{"excerpt":"1. 新建Buffer会占用V8分配的内存吗？ 不会，Buffer属于堆外内存，不是V8分配的 2. Buffer的内存分配机制 Buffer对象类似数组，它的元素为16进制的两位数，即0到255的数值。其内存分配是在Node的C++层面实现的内存的申请，但是在JavaScript层面分配内存。Node采用了slab分配机制，以8KB为界限区分Buffer是大对象还是小对象。 小对象（<8KB）： 采用slab的机制进行预先申请和事后分配的策略。例如第一次分配一个1024字节的Buffer…","fields":{"slug":"/nodejs-cha-lou-bu-que-buffer-xiang-guan/"},"frontmatter":{"title":"Nodejs查漏补缺-Buffer相关","tags":["Node"],"star":false,"date":"16 Aug 2020","author":"烈风裘"}}},{"node":{"excerpt":"1. 从用户态发出异步I/O调用后，到回调函数被执行，中间发生了什么？ 因为Node中的异步I/O调用不是有开发者自己调用的。示例代码如下： 整个异步I/O的流程如下：  请求对象、I/O线程池、观察者、 事件循环 这四个共同构成了Node异步I/O模型的基本要素。大致流程： 创建FSReqWrap请求对象，包括传参、当前方法、回调函数等都在请求对象中； 将请求对象放入线程池中等待执行； 线程执行完毕后，将结果存储在请求对象中，通知IOCP 事件循环的观察者在每次Tick的执行中，调用IOCP…","fields":{"slug":"/nodejs-cha-lou-bu-que-yi-bu-xiang-guan/"},"frontmatter":{"title":"Nodejs查漏补缺-异步相关","tags":["Node"],"star":false,"date":"16 Aug 2020","author":"烈风裘"}}},{"node":{"excerpt":"1 请介绍一下node里的模块是什么？ Node中，每个文件模块都是一个对象，它的接口  定义如下： 所有的模块都是 Module 的实例。module.exports 的定义就在这里体现，默认是空对象！ 这里的module.js引用subModules.js文件，打印module.js中的的  变量的结果： 2. 我们知道node导出模块有两种方式，一种是 exports.xxx=xxx 和module.exports…","fields":{"slug":"/nodejs-cha-lou-bu-que-mo-kuai-xiang-guan/"},"frontmatter":{"title":"Nodejs查漏补缺-模块相关","tags":["Node"],"star":false,"date":"16 Aug 2020","author":"烈风裘"}}}]}},"pageContext":{"tag":"Node"}},"staticQueryHashes":["3240721340","63159454"]}