{"componentChunkName":"component---src-templates-blog-post-js","path":"/guan-yu-mai-man-dian-qian-jian-tan/","result":{"data":{"site":{"siteMetadata":{"title":"Attila","cover":"/background/1.jpg","description":"Thoughts, stories and ideas.","keywords":["烈风裘的博客","X-Blog","Attila","Gatsby","前端成长记录"],"tagCover":"/background/5.jpg","archiveCover":"/background/escape-flight.png","siteUrl":"https://xiangst0816.github.io/blog","logo":"","navigation":true,"subscribe":true}},"allAuthorJson":{"totalCount":2,"edges":[{"node":{"id":"烈风裘","bio":"一往无前, 直到云开雾散!","avatar":"/avatar/me.jpeg","cover":"/background/photo-1503197979108-c824168d51a8.jpeg","github":"https://github.com/xiangsongtao","twitter":"","zhihu":"","weibo":"","facebook":"","website":"https://xiangsongtao.github.io/blog/","location":"HangZhou, China"}},{"node":{"id":"WALL-E","bio":"还有要清理的吗?","avatar":"/avatar/cleaner.jpg","cover":"","github":null,"twitter":null,"zhihu":null,"weibo":null,"facebook":null,"website":null,"location":"Earth"}}]},"master":{"id":"烈风裘","bio":"一往无前, 直到云开雾散!","avatar":"/avatar/me.jpeg","cover":"/background/photo-1503197979108-c824168d51a8.jpeg","github":"https://github.com/xiangsongtao","twitter":"","zhihu":"","weibo":"","facebook":"","website":"https://xiangsongtao.github.io/blog/","location":"HangZhou, China"},"currentPost":{"html":"<p>埋点适用于分析用户的使用行为，通过搜集分析数据推进用户体验，进而优化产品或者挖掘用户习惯推出新产品等。</p>\n<p>埋点方式分为前端和后端，这里主要谈谈前端的实现。埋点方案现在业界已经比较成熟了，可分为：有码埋点、可视化埋点、无码埋点三种，<a href=\"http://www.jianshu.com/p/afd601e07bf0\" target=\"_target\" rel=\"nofollow\">这里是介绍</a>。简单的说就是这样：</p>\n<ul>\n<li>有码埋点: 埋点锚点植入业务代码中描述 优点 缺点埋点锚点植入业务代码中(JS 或者 HTML 中) 高耦合，精确控制 技术人员手工添加修改因为无代码，不移维护修改，易出错，埋点前的方案都清楚</li>\n<li>可视化埋点 通过元素的页面结构定位埋点位置，业务代码与埋点代码分离 可对线上代码修改，</li>\n</ul>\n<h4 id=\"有码埋点\" style=\"position:relative;\"><a href=\"#%E6%9C%89%E7%A0%81%E5%9F%8B%E7%82%B9\" aria-label=\"有码埋点 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>有码埋点</h4>\n<p>熟悉 Google Analytics 的同学都知道这个，除了 PV 统计外，GA 还提供了追踪访客和网站的互动的功能，尤其是追踪那些不产生新页面的访问行为（例如下载文件），很多类似的产品都叫自定义事件功能，说的就是它。有码埋点是目前业内最为熟悉且被广泛采用的一种数据接入手段。</p>\n<p>拿 Google Analytics 为例，可以利用_trackEvent()方法来进行事件追踪。它的详细参数如下：_trackEvent(category, action, opt<em>label, opt</em>value, opt_noninteraction)</p>\n<ul>\n<li>category（必需）：类别</li>\n<li>action（必需）：和用户的行为对应，例如“下载”</li>\n<li>label：标签，其他有关信息</li>\n<li>value：提供数值型数据</li>\n<li>non-interaction：布尔值。</li>\n</ul>\n<p>如果你想在追踪链接的，给需要追踪的链接调用_trackEvent()方法并设置参数，加上调用的方法 onclick 即可。优点是可以对发送的内容做到精准控制，对于上线后影响因素较小数据埋点它无疑是最适用的。缺点也很明显，对页面元素的埋点都需要手工添加代码，工作量无疑是巨大的，必须是技术人员参与才能完成，埋点地方过多也容易出错。代码埋点的理想化在于事先把数据收集方案都想明白，而在实际情况下很难做到。</p>\n<h4 id=\"可视化埋点\" style=\"position:relative;\"><a href=\"#%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9F%8B%E7%82%B9\" aria-label=\"可视化埋点 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>可视化埋点</h4>\n<p>有码埋点无疑是苦逼的，成本高而且容易出错，如果想修改的话还得重新上线，尤其对 APP 开发者来说更是苦难，漫长的审核期客户端的更新成本都是不容忽略的。</p>\n<p>所以为了解决这些问题，有些专业做数据分析的厂商提出来更加敏捷和聪明的方案，以 Kissmetrics 和 Mixpanel 为代表的数据分析服务商提供了可视化埋点的方案，以 Click to Track 的方式代替了手工埋点，<strong>实现了埋点的配置与应用本身的分离</strong>，每次用户打开应用时，只需要把新的埋点配置重新下载到客户端即可，而无须频繁更新客户端版本。拿 Kissmetrics 为例，</p>","timeToRead":2,"wordCount":{"paragraphs":16,"sentences":16,"words":115},"fields":{"slug":"/guan-yu-mai-man-dian-qian-jian-tan/","relativePath":"2017/2017-01-22---guan-yu-mai-man-dian-qian-jian-tan/index.md"},"excerpt":"…","frontmatter":{"title":"关于埋点浅谈","date":"22 Jan 2017","tags":["埋点"],"cover":"","comments":true,"author":"烈风裘"}},"nextPost":{"html":"<blockquote>\n<p>下面列出来的是 JavaScript 总结大纲，详细内容会继续展开，待续。。</p>\n</blockquote>\n<h2 id=\"基础\" style=\"position:relative;\"><a href=\"#%E5%9F%BA%E7%A1%80\" aria-label=\"基础 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>基础</h2>\n<ul>\n<li>\n<p>数据类型相关</p>\n<ul>\n<li>基础类型(Number/String/Boolean/Null/undefined)</li>\n<li>引用类型(object/function/array/date)</li>\n<li>深浅拷贝</li>\n<li>类型对应的操作方法</li>\n</ul>\n</li>\n<li>\n<p>函数相关</p>\n<ul>\n<li>内部属性(this)</li>\n<li>外部属性(arguments/length/name/protorype)</li>\n<li>call/apply</li>\n<li>bind</li>\n<li>作用域及作用域链</li>\n<li>类/闭包/原型继承</li>\n<li>模块化</li>\n<li>错误及调试</li>\n</ul>\n</li>\n<li>\n<p>Ajax</p>\n<ul>\n<li>创建过程</li>\n<li>响应码 readystate</li>\n<li>跨域请求</li>\n<li>请求方式</li>\n<li>jsonp</li>\n</ul>\n</li>\n<li>\n<p>jQuery</p>\n<ul>\n<li>流式 API</li>\n<li>DOM 操作</li>\n<li>通用工具及方法</li>\n<li>选择器及事件队列</li>\n<li>ajax 方法</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"进阶\" style=\"position:relative;\"><a href=\"#%E8%BF%9B%E9%98%B6\" aria-label=\"进阶 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>进阶</h2>\n<ul>\n<li>雅虎军规熟记</li>\n<li>代码优化</li>\n<li>HTML/CSS/JavaScript 书写结构优化</li>\n<li>请求优化</li>\n<li>合理分流</li>\n<li>\n<p>移动端性能优化</p>\n<ul>\n<li>网络传输优化</li>\n<li>DOM 操作优化</li>\n<li>内存资源优化</li>\n<li>体验优化</li>\n</ul>\n</li>\n<li>\n<p>常见算法</p>\n<ul>\n<li>冒泡排序</li>\n<li>插入排序</li>\n<li>希尔排序</li>\n<li>快速排序</li>\n</ul>\n</li>\n<li>\n<p>数据结构</p>\n<ul>\n<li>数组</li>\n<li>列表</li>\n<li>栈</li>\n<li>队列</li>\n<li>链表</li>\n<li>字典</li>\n<li>散列</li>\n<li>集合</li>\n<li>二叉树</li>\n<li>图</li>\n<li>排序算法</li>\n<li>检索算法</li>\n</ul>\n</li>\n<li>\n<p>高性能 JavaScript</p>\n<ul>\n<li>脚本加载和执行</li>\n<li>数据存储</li>\n<li>DOM 操作</li>\n<li>算法和流程控制</li>\n<li>字符串及正则</li>\n<li>控制 js 处理时长</li>\n<li>ajax 异步数据的运用</li>\n<li>语言使用习惯(eval/with/new/原生方法)</li>\n<li>js 压缩/Gzip/md5 命名/CDN</li>\n</ul>\n</li>\n<li>\n<p>常用 JS 框架</p>\n<ul>\n<li>reactjs</li>\n<li>vuejs</li>\n<li>angularjs 1.x</li>\n<li>jquery</li>\n<li>zepto</li>\n<li>lodash</li>\n<li>nodejs</li>\n<li>express</li>\n</ul>\n</li>\n<li>\n<p>构建工具</p>\n<ul>\n<li>gulp</li>\n<li>webpack</li>\n<li>fis</li>\n<li>yeoman</li>\n</ul>\n</li>\n<li>\n<p>MVC/MVVM 概念</p>\n<ul>\n<li>区别</li>\n<li>框架代表</li>\n<li>使用范围</li>\n</ul>\n</li>\n<li>\n<p>ECMAScript5</p>\n<ul>\n<li>语法</li>\n<li>babel</li>\n<li>promise</li>\n</ul>\n</li>\n</ul>","timeToRead":2,"wordCount":{"paragraphs":89,"sentences":89,"words":136},"fields":{"slug":"/JavaScript-he-hu-xin-ji-neng-nai-dian/","relativePath":"2016/2016-12-27---JavaScript-he-hu-xin-ji-neng-nai-dian/index.md"},"excerpt":"下面列出来的是 JavaScript 总结大纲，详细内容会继续展开，待续。。 基础 数据类型相关 基础类型(Number/String/Boolean/Null/undefined) 引用类型(object…","frontmatter":{"title":"JavaScript 核心技能点","date":"27 Dec 2016","tags":["随笔"],"cover":"","comments":true,"author":"烈风裘"}},"prevPost":{"html":"<p>移动端组件的编写和 PC 端组件的编写是不同的，PC 端组件见的通讯及状态共享很简单，基本上井水不犯河水，但是移动端组件的却不是这样：ion-title 组件希望共享自己的控制权，便于业务动态修改、menu 组件弹开的手，希望页面也能向右移动下、页面切换的时候，自动关闭 ActionSheet 组件等。下面是我在组件编写时踩得坑，如果感兴趣或者有同样的思考可以和我联系。</p>\n<h2 id=\"组件间通讯\" style=\"position:relative;\"><a href=\"#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E8%AE%AF\" aria-label=\"组件间通讯 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>组件间通讯</h2>\n<p>基础组件的组件见通讯使用的比较多，比如 menu 组件打开需要通知 nav 组件是否移动等，如果直接上 Vuex，基础组件间的通讯与业务逻辑的通讯将混为一起，不方便开发调试。另外，项目是否上 Vuex 也是未知数，所以这里确定：vueMobile 组件间通讯走 EventBus，业务间状态同步是否上 Vuex 根据规模选择使用。这也算是自己编写组件前一致坚持的：</p>\n<blockquote>\n<p>我想在编写业务页面的时候，能清爽一点。</p>\n</blockquote>\n<p>下图是简单的机构说明：</p>\n<p><img src=\"\"></p>\n<h2 id=\"公共组件方法提取\" style=\"position:relative;\"><a href=\"#%E5%85%AC%E5%85%B1%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95%E6%8F%90%E5%8F%96\" aria-label=\"公共组件方法提取 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>公共组件方法提取</h2>\n<p>基础组件通过 Vue.install 安装到全局，但是组件中的某些方法是需要在业务代码中直接调用的，比如控制页面是否能滚动、是否能点击、设置标题、返回顶部等方法。另一方面，组件在注册返回的始终是构造器，而不是<code class=\"language-text\">鲜活的</code>组件实例：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 获取注册的组件（始终返回构造器）\nvar MyComponent = Vue.component(&#39;my-component&#39;)</code></pre></div>\n<p>也就是说：<strong>组件只有被页面初始化的时候才会存在生命，才存在这个组件内部的 this</strong>。</p>\n<h3 id=\"子组件希望共享对自己的控制权，这个怎么做？\" style=\"position:relative;\"><a href=\"#%E5%AD%90%E7%BB%84%E4%BB%B6%E5%B8%8C%E6%9C%9B%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%87%AA%E5%B7%B1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%9D%83%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F\" aria-label=\"子组件希望共享对自己的控制权，这个怎么做？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>子组件希望共享对自己的控制权，这个怎么做？</h3>\n<p>比如业务页面中的<code class=\"language-text\">ion-title</code>组件自身实现了<code class=\"language-text\">setTitle</code>方法来控制 Title 的显示，但是这个方法希望在业务页面中能调用，方便用户自定义 Title(包括修改 document.title 的 Hack 方法)。例如如下的结构：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ion-page</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ion-header</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ion-navbar</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ion-title</span> <span class=\"token attr-name\">slot</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>content<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Demo</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ion-title</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ion-navbar</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ion-header</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ion-content</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">content</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ion-content</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ion-page</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>这样的需求实现有两个方法：</p>\n<ol>\n<li><strong>在业务 this 中找到子组件的 this</strong>：在业务页面的 this 通过逐层查找$children 中 ion-title 组件，然后执行找到的组件的 child.setTitle(val)方法。</li>\n<li><strong>子组件将自己放到全局</strong>：ion-title 组件初始化时，向全局挂载，比如挂载到 Vue 的 prototype 上：<code class=\"language-text\">Vue.prototype.setTitle=ins.setTitle</code>；或者挂载到 window 上。当页面切换后，需要重复此操作。挂载到 Vue 上，业务页面可以通过 this 访问到，并且页面模板也能直接使用，较为方便。</li>\n</ol>\n<p>另外，路由开启<code class=\"language-text\">keep-alive</code>时，组件也能正常工作的情况别忘记考虑，此时页面切换只有<code class=\"language-text\">activated/deactivated</code>钩子工作，业务内的组件不会因为外面是<code class=\"language-text\">keep-alive</code>而自我更新的，相当于变成了<strong>墓碑</strong>。</p>\n<p>此外，<code class=\"language-text\">ion-page</code>外层的<code class=\"language-text\">ion-app/ion-nav</code>是所有业务页面公用的，每次业务页面切换再提取父组件的内容可能不太合适。</p>\n<p>因此，vueMobile 组件是这样做的：</p>\n<ol>\n<li>业务页面的子组件使用 mixins 遍历 this 提取公共方法，提取方法在 created 和 activated 钩子上都注册方法，挂载前判断是否已挂载；</li>\n<li>业务页面的父组件使用 Vue.prototype 将自己挂载到全局上。</li>\n</ol>\n<p>下面是对这个过程的说明：</p>\n<p><img src=\"\"></p>\n<h2 id=\"backdrop-组件\" style=\"position:relative;\"><a href=\"#backdrop-%E7%BB%84%E4%BB%B6\" aria-label=\"backdrop 组件 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Backdrop 组件</h2>\n<p>同时打开两个带有 Backdrop 的 Loading 组件，这个该怎么显示呢？答案是只显示一次 Backdrop！因此 Backdrop 组件的设计需要脱离 Loading、Toast、ChooseSheet 等组件。</p>\n<h2 id=\"choosesheet-组件\" style=\"position:relative;\"><a href=\"#choosesheet-%E7%BB%84%E4%BB%B6\" aria-label=\"choosesheet 组件 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ChooseSheet 组件</h2>\n<p>其实这个组件是 ActionSheet 的变种，因为此组件的展现样式被发现在多处被使用到，比如：Timepicker、购物车、选择商品尺码、选择地址等。</p>","timeToRead":4,"wordCount":{"paragraphs":23,"sentences":23,"words":175},"fields":{"slug":"/vueMobile-zu-jian/","relativePath":"2017/2017-02-06---vueMobile-zu-jian/index.md"},"excerpt":"移动端组件的编写和 PC 端组件的编写是不同的，PC 端组件见的通讯及状态共享很简单，基本上井水不犯河水，但是移动端组件的却不是这样：ion-title 组件希望共享自己的控制权，便于业务动态修改、menu…","frontmatter":{"title":"vueMobile组件(组件间通讯)","date":"06 Feb 2017","tags":["Vue","Mobile","组件通信"],"cover":"","comments":true,"author":"烈风裘"}}},"pageContext":{"curr":"/guan-yu-mai-man-dian-qian-jian-tan/","prev":"/vueMobile-zu-jian/","next":"/JavaScript-he-hu-xin-ji-neng-nai-dian/"}},"staticQueryHashes":["3240721340","63159454"]}