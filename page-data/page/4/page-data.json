{"componentChunkName":"component---src-pages-index-js","path":"/page/4","result":{"data":{"site":{"siteMetadata":{"title":"Attila","cover":"/background/1.jpg","author":"@烈风裘","description":"Thoughts, stories and ideas.","keywords":["烈风裘的博客","X-Blog","Attila","Gatsby","前端成长记录"],"tagCover":"/background/5.jpg","archiveCover":"/background/escape-flight.png","siteUrl":"https://xiangst0816.github.io/blog","logo":"","navigation":true,"subscribe":true}},"allAuthorJson":{"totalCount":2,"edges":[{"node":{"id":"烈风裘","avatar":"/avatar/avatar.jpeg"}},{"node":{"id":"WALL-E","avatar":"/avatar/cleaner.jpg"}}]},"allMarkdownRemark":{"totalCount":87},"currentMarkdownRemark":{"totalCount":87,"edges":[{"node":{"excerpt":"1. DOM 选择符 API 根据 CSS 选择符 选择与某个模式匹配的 DOM 元素.  IE8+, 返回第一个匹配的 Node  IE8+, 返回 NodeList  IE9+, 如果调用元素与该选择符匹配，返回 true；否则，返回 false。 这个 API 并未全部支持, 可用下面方式使用: 2. ElementNode 类型 Node 查询增强 API childElementCount：返回子元素（不包括文本节点和注释）的个数。 firstElementChild…","fields":{"slug":"/di-shi-yi-zhang-DOM-tuo-ta-zhi-zhan/"},"frontmatter":{"title":"第十一章 DOM拓展","tags":["JS高程"],"star":false,"date":"04 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. 对 DOM 树形结构的理解? DOM 解释 DOM(文档对象模型), 是针对类 HTML 层次化节点树操作的一个API(应用程序编程接口)集合. 用于更改底层文档及外观结构. 根节点 树中的节点可以由多种Node 类型组成, 根节点称之为文档元素(传说的), 即. Node 类型 类型可以是: Node.ELEMENT_NODE(1)；子元素 Node.ATTRIBUTE_NODE(2)； Node.TEXT_NODE(3)； 文本 Node.CDATASECTIONNODE(…","fields":{"slug":"/di-shi-zhang-DOM/"},"frontmatter":{"title":"第十章 DOM","tags":["JS高程"],"star":false,"date":"04 Mar 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. ////这些对象的含义和区别? ，它表示浏览器的一个实例  对象还是 ECMAScript 中的  对象，因而所有全局变量和函数都是它的属性，且所有原生的构造 函数及其他函数也都存在于它的命名空间下 此外, 页面可能包含很多 frames  对象始终指向最外围的框架(frames)，也就是整个浏览器窗口  对象表示包含当前框架的框架，而 self 对象则回指  在没有框架的情况下， 一定等于 （此时它们都等于 ） 与框架有关的最后一个对象是 self…","fields":{"slug":"/di-ba-zhang-BOM/"},"frontmatter":{"title":"第八章 BOM","tags":["JS高程"],"star":false,"date":"28 Feb 2018","author":"烈风裘"}}},{"node":{"excerpt":"至少是我这里的前端开发都是自顶向下的模式, 即先按照支持程度最高的浏览器上开发, 之后再适配其他浏览器. 因此, 适配过程就需要对不同的客户端. 能力检测 H5 能力检测, 比如这个库: modernizr 怪癖检测(Bug 检测) 一般情况下不推荐使用. userAgent 检测 一般通过正则匹配 userAgent 进行平台鉴别. 例如: UAParser.js Lightweight JavaScript-based User-Agent String Parser","fields":{"slug":"/di-jiu-zhang-ke-hu-duan-jian-ce/"},"frontmatter":{"title":"第九章 客户端检测","tags":["JS高程"],"star":false,"date":"28 Feb 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. 对象定义? 无需属性的集合, 其属性可以包含基本值/对象/函数; 或者, 没有特定顺序的散列表. 或者, 使用 js 实现一个散列表?\n答: var a = {}; 2. 操作符执行的过程? 3. 下面的输出结果是? 4. 谈谈你对 prototype 的理解? 每个函数都有一个(原型)属性, 这个属性是一个指针, 指向 prototype 原型对象 prototype 原型对象的用途是包含可以由特定类型的所有实例共享的属性和方法 prototype…","fields":{"slug":"/di-liu-lu-zhang-mian-xiang-dui-xiang/"},"frontmatter":{"title":"第六章 面相对象的程序设计","tags":["JS高程"],"star":false,"date":"26 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"1. 下面代码返回什么, 位置 3~98 返回什么? 说明: array 类型的 length 属性不是只读的, 设置 length 可以对数组动态缩减及扩容. 可根据需要动态添加数据, length 自动叠加, 中间未定义的数据为 undefined 2. 数组复制的方法有哪些? 3. 不影响原值的情况下, 获取数组最后一个元素的方法有哪些? 4. 理解 Function, 实现方法的 polyfill…","fields":{"slug":"/di-wu-zhang-yin-yong-lei-xing/"},"frontmatter":{"title":"第五章 引用类型","tags":["JS高程"],"star":false,"date":"21 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"问答 1. 何为基本类型和引用类型? 基本类型: 简单的数据段, 类型如, undefined, null, boolean, string, number; 引用类型: 值保存在堆内存中的对象, 通过地址访问. 2. 函数传递参数时, 基础类型是按值传递/引用类型是按引用传递? 回答: 全部是按值传递!! 当在向参数传递引用类型的值时, 会把这个值在堆内存中的地址复制给一个局部变量. 可以把 ECMAScript…","fields":{"slug":"/di-si-zhang-bian-liang/"},"frontmatter":{"title":"第四章 变量-作用域和内存问题","tags":["JS高程"],"star":false,"date":"20 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"问答 1. 函数声明的语法是? 2. 函数表达式(匿名函数)的语法是? 3. 以下递归语句是否报错, 报错原因是? 如何改进? 错误: Uncaught TypeError: factorial is not a function 原因: 函数 factorial 内部的 factorial 指向 null, 因此报错. 方法 1: arguments.callee, 它指向当前正在执行的函数指针. 但是严格模式不允许使用. 方法 2: 函数表达式…","fields":{"slug":"/di-qi-zhang-han-shu-shuo-biao-da-shi/"},"frontmatter":{"title":"第七章 函数表达式","tags":["JS高程"],"star":false,"date":"08 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"写代码的时候经常用到，但是被问起却哑口无言，或者只能说到表面，这里再详细总结写，查漏补缺。 介绍 JavaScript…","fields":{"slug":"/bi-bao/"},"frontmatter":{"title":"闭包","tags":["JavaScript"],"star":false,"date":"01 Jan 2018","author":"烈风裘"}}},{"node":{"excerpt":"就是下面这样的的代码： 关于 IIFE 书写方式 第一种情况： 解释：JavaScript 在解析代码时，当遇到关键字时，会默认把它当做一个函数声明，而不是函数表达式，如果没有把它显式的写成函数表达式，就报错，因为函数声明需要一个函数名。上面的报错是因为没有函数名(第一个左括号)。 第二种情况： 解释：在表达式后面加括号表示执行；此外，在函数声明一个语句，在语句后面加括号可等价为： 相当于声明了函数 foo…","fields":{"slug":"/IIFE-li-ji-zhi-hang-xing-han-shu-shuo/"},"frontmatter":{"title":"IIFE立即执行函数","tags":["JavaScript"],"star":false,"date":"01 Jan 2018","author":"烈风裘"}}}]}},"pageContext":{"skip":30,"limit":10}},"staticQueryHashes":["3240721340","63159454"]}